#!/usr/bin/env node
/*
 * vim: set ft=javascript :
 *
 * rotcelloc command-line management app
 *
 * Part of rotcelloc - the hacker's movie, tv-series and game collection
 * manager
 *
 * Copyright (C) Eskild Hustvedt 2015, 2016, 2017
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
// jshint esversion: 6

"use strict";

// Load modules
try
{
    // eslint-disable-next-line no-var
    var
        // For parsing the collection files
        parse         = require('csv').parse,
        // Needed to perform filesystem operations
        fs            = require('fs'),
        // Used to retrieve movie art
        movieArt      = require('movie-art'),
        // Used to make async stuff be synchronous for command-line use
        wait          = require('wait.for'),
        // Perform HTTP requests
        httpreq       = require('httpreq'),
        // Used to clean up paths
        path          = require('path'),
        // Various helpers
        _             = require('lodash'),
        // Perform glob operations to easily perform actions on covers
        glob          = require('glob'),
        // Command-line parameter parsing
        commander     = require('commander'),
        // Used to call system commands
        child_process = require('child_process'),
        // Used for printf-like formatting
        util          = require('util'),
        // Scrapes Steam to retreive the list of games a Steam user owns
        steam         = require('happy-steam-scraper'),
        // Used to decode HTML entities
        he            = require('he'),
        // Used to parse APIs that return XML instead of JSON
        xml2json      = require('xml2json'),
        // Used to compile our template
        ejs           = require('ejs'),
        // Used to minify JS
        UglifyJS      = require("uglify-js"),
        // Converts PO files to a JSON structure
        po2json       = require('po2json'),
        // Loads CSON files
        CSON          = require('cson'),
        // Used for hashing
        crypto        = require('crypto'),
        // Used to fetch book metadata
        isbn          = require('node-isbn'),
        // Used to resize and identify images
        gm            = require('gm'),
        // Used to compile the client-side JS
        babel         = require('babel-core');

}
    catch(e)
{
    console.log('You are missing some rotcelloc dependencies: '+e.message);
    console.log('Please install the dependencies with "yarn install" or "npm install" and try again');
    process.exit(1);
}

// eslint-disable-next-line no-var
var
    // Global cache object
    cache = null,
    // Used for caching data during a single run
    runtimeCache = {
        // The config file
        config: null,
        // Used posters
        postersUsed: {}
    },
    // Stores a parsed version of package.json, basically just used
    // to lazily get our version number without having to duplicate it
    // in multiple files.
    packageJSON = null,
    // Output directory
    outputDir = null,
    // Global i18n handling (including translation function)
    i18n = {
        strings: {},
        translate (s)
        {
            return this.strings[s] ? this.strings[s] : s;
        }
};

/*
 * Cache class
 */
class rotcellocCache
{
    constructor ()
    {
        // This is where we store the cache data
        this._persistCache = {};
        // Used to keep track of the number of times the cache data has
        // been changed since the last time we wrote it to disk.
        this._writesSinceFlush = 0;

        // Used for *all* access bumps during this objects lifetime
        this._objectLifetimeID = Math.floor(Date.now() / 1000);
        // Used to check how long it is since we last did a write
        // to avoid writing too often
        this._lastWritten = 0;
        // Our current formatVersion
        this._currFormatVersion = 1;

        // Load and initialize _persistCache
        if(fs.existsSync(helper.resolveOutPath('.rotcellocdata/cache.json')))
        {
            printv(3,'Loading cache from .rotcellocdata/cache.json');
            this._persistCache = JSON.parse(fs.readFileSync(helper.resolveOutPath('.rotcellocdata/cache.json')));
        }
        // Version 1 'miss' values are deprecated, so we force an upgrade if
        // the cache is version 1
        if(this._persistCache.formatVersion < 1)
        {
            printv(3,'Forcing retryMiss in order to upgrade the cache');
            commander.retryMiss = true;
        }
        // Check if the cache is newer than we are
        if(this._persistCache.formatVersion > this._currFormatVersion)
        {
            console.log('The cache file format is newer than rotcelloc.');
            console.log('You will need to either upgrade rotcelloc or delete');
            console.log('.rotcellocdata/cache.json');
            process.exit(1);
        }
        // Initialize all of the various caches if needed
        if (!this._persistCache.posterFiles)
        {
            this._persistCache.posterFiles = {};
        }
        if (!this._persistCache.meta)
        {
            this._persistCache.meta = {};
        }
        if (!this._persistCache.gameMeta)
        {
            this._persistCache.gameMeta = {};
        }
        if (!this._persistCache.bookMeta)
        {
            this._persistCache.bookMeta = {};
        }
        if (!this._persistCache.steamMeta)
        {
            this._persistCache.steamMeta = {};
        }
        if (!this._persistCache.arbitrary)
        {
            this._persistCache.arbitrary = {};
        }
        if (!this._persistCache.externalAPI)
        {
            this._persistCache.externalAPI = {};
        }
        if (!this._persistCache._meta)
        {
            this._persistCache._meta = {};
        }
    }

    /*
     * Retrieves a value from the cache
     */
    get (cacheType,ckey)
    {
        if(this._persistCache[cacheType] === undefined)
        {
            throw('Attempt to get() from unknown cache type: '+cacheType);
        }
        this.bumpAccessTime(cacheType,ckey);
        return this._persistCache[cacheType][ckey];
    }

    /*
     * Sets a value in the cache
     */
    set (content,cacheType,ckey)
    {
        if(this._persistCache[cacheType] === undefined)
        {
            throw('Attempt to set() to unknown cache type: '+cacheType);
        }
        // JSON doesn't store "undefined", so we make it "null" instead.
        // null is treated as "an attempt has been made to find the value this
        // entry should have had, but it failed". Used to avoid making useless API
        // calls to fetch data that's not there on each run.
        if(content === undefined)
        {
            content = null;
        }
        // We make deep clones for data in the cache so that any modifications made
        // by the caller after setting the cache won't also modify the cached value
        this._persistCache[cacheType][ckey] = _.cloneDeep(content);
        this.bumpAccessTime(cacheType,ckey);
        this._writesSinceFlush++;
        this.autoWrite();
    }

    /*
     * Checks if a value exists in the cache for the supplied cache key
     */
    exists(cacheType,ckey)
    {
        if(this._persistCache[cacheType] === undefined)
        {
            throw('Attempt to exists() with unknown cache type: '+cacheType);
        }
        return this._persistCache[cacheType][ckey] !== undefined;
    }

    // This works like exists() but if commander.retryMiss is true it will
    // consider keys that exist but whose values are null as if they don't
    // exist.
    existsNotMiss(cacheType,ckey)
    {
        if(!commander.retryMiss)
        {
            return this.exists(cacheType,ckey);
        }
        if(this.exists(cacheType,ckey))
        {
            const entry = this.get(cacheType,ckey);
            if(entry === null || entry === 'MISS')
            {
                return false;
            }
        }
        return true;
    }

    /*
     * This works like set(), but it will compare the existing value in the
     * cache with the new value in the cache to avoid rewriting identical
     * values, and thus save time by reducing write() calls for no good reason.
     * NOTE: The comparison is made with "===", so this only works with very
     * simple values such as strings and numbers.
     */
    lazySet (content,cacheType,ckey)
    {
        if(this.get(cacheType,ckey) !== content)
        {
            return this.set(content,cacheType,ckey);
        }
    }

    /*
     * This bumps the "access time" for a key. Access times are
     * used to check if a cache entry has been retrieved or written to
     * recently, so that we can expire outdated entries
     */
    bumpAccessTime (cacheType,ckey)
    {
        this._persistCache._meta[ cacheType + '___' + ckey ] = this._objectLifetimeID;
    }

    /*
     * This is a variant of "get" that will generate the ckey automatically
     */
    getAutoKey(cacheType,entry,type,opts)
    {
        const ckey = getCacheID(entry,type,opts);
        return this.get(cacheType,ckey);
    }

    /*
     * This is a variant of "set" that will generate the ckey automatically
     */
    setAutoKey(content,cacheType,entry,type,opts)
    {
        const ckey = getCacheID(entry,type,opts);
        return this.set(content,cacheType,ckey);
    }

    /*
     * Deletes a value from the cache
     */
    unset(cacheType,ckey)
    {
        delete this._persistCache[cacheType][ckey];
        this.autoWrite();
    }

    /*
     * This is a variant of "unset" that will generate the ckey automatically
     */
    unsetAutoKey(cacheType,entry,type,opts)
    {
        const ckey = getCacheID(entry,type,opts);
        return this.unset(cacheType,ckey);
    }

    /*
     * Writes the cache to disk. This will ALWAYS trigger a write, even if
     * we haven't modified the cache data since the last write
     */
    write()
    {
        this._writesSinceFlush = 0;
        this._lastWritten = Math.floor(Date.now() / 1000);
        this._persistCache.lastVersion = packageJSON.version;
        this._persistCache.formatVersion = this._currFormatVersion;
        this._persistCache.lastObjID = this._objectLifetimeID;
        printv(5,'Writing cache to .rotcellocdata/cache.json');
        fs.writeFileSync('.rotcellocdata/cache.json.out',JSON.stringify(this._persistCache));
        fs.renameSync('.rotcellocdata/cache.json.out','.rotcellocdata/cache.json');
    }

    /*
     * Writes cache data to disk if it has been modified more than 50 times
     * since the last write and it has been more than 4 seconds since the last
     * write
     */
    autoWrite()
    {
        if(this._writesSinceFlush > 50)
        {
            const now = Math.floor(Date.now() / 1000);
            if(now-this._lastWritten >= 4)
            {
                this.write();
            }
        }
    }

    /*
     * Variant of write() that only writes the cache to disk if it has been
     * modified since the last time we wrote it. This is almost always what you
     * want
     */
    flushIfNeeded()
    {
        if(this._writesSinceFlush > 0)
        {
            this.write();
        }
    }

    /*
     * Method that expires all cache entries that case-insensitively matches
     * 'byvalue'
     */
    cacheExpiry (byvalue)
    {
        byvalue = byvalue.toLowerCase();
        for (const type of [ 'meta', 'gameMeta','bookMeta','arbitrary','steamMeta' ])
        {
            const result = this._persistCache[type];
            for (const entry in result)
            {
                if(entry.toLowerCase().indexOf(byvalue) !== -1 || byvalue === '')
                {
                    console.log(type+': removed "'+entry+'"');
                    delete result[entry];
                }
            }
            if(type === 'steamMeta')
            {
                for(const entry in result)
                {
                    const data = result[entry];
                    if(data.name && data.name.toLowerCase().indexOf(byvalue) !== -1)
                    {
                        console.log(type+': removed "'+entry+'"');
                        delete result[entry];
                    }
                }
            }
        }
        this.write();
    }

    /*
     * Expires all outdated entries in the cache, based upon their last access
     * time
     */
    autoExpireOutdatedEntries ()
    {
        const now = Math.floor(Date.now() / 1000);
        for (const type of [ 'meta', 'gameMeta','arbitrary','steamMeta' ])
        {
            const result = this._persistCache[type];
            for (const entry in result)
            {
                const accessKey = type + '___' + entry;
                // 100800 seconds = four weeks
                if (this._persistCache._meta[accessKey] === undefined || (now-this._persistCache._meta[accessKey]) >= 100800)
                {
                    this._writesSinceFlush++;
                    printv(7,'Removed expired cache entry of type '+type+' for '+entry);
                    delete result[entry];
                }
            }
        }
    }
}

/*
 * Base class for all collection types. Implements generic versions of
 * most methods which can then be overridden
 */
class collectionType
{
    constructor(entry, name, groupNumber)
    {
        // Permanent references to the entry, name and groupNumber
        this._entry = entry;
        this._name = name;
        this._groupNo = groupNumber;
        // Stores the basename of the current data source (usually basename of
        // an ics file)
        this._curBsource = null;
        // Stores the full name/path of the current data source
        this._curSource = null;
        // Initializes various metadata that the frontend needs
        this._meta = {
            sourceToNameMap: {},
            fields: {},
            type: this._entry.type
        };
        // Calls initialization on our parent if it has one
        if(this.initialize)
        {
            this.initialize();
        }
    }

    /*
     * Load data from a source. This is a stupid version that only supports loading
     * CSV-files (and assumes everything is a CSV-file). Subclasses can override this
     * method to support more data sources
     */
    loadData(source)
    {
        return this.loadCSVData(source);
    }

    /*
     * Loads data from a CSV-file
     */
    loadCSVData(entry)
    {
        printv(3,'Interpreting file "'+entry.file+'"');
        // Add a basename-to-full-path map
        this._meta.sourceToNameMap[path.basename(entry.file)] = entry.name;
        // Set the current bSource
        this._curBsource = path.basename( entry.file );

        const input  = fs.readFileSync(helper.resolveOutPath(entry.file),{ encoding: 'utf-8'} );
        const CSV = wait.for(parse,input, {comment: '#', delimiter: ';', trim: true, columns: true, relax_column_count: true, skip_empty_lines: false});
        const config = helper.getConfig();
        let blameData;
        // If automatic 'added' dates are enabled, load that data from git
        if(config.enableAutoAdded !== false)
        {
            blameData = this.loadGitBlame(entry.file);
        }
        for(let i = 0; i < CSV.length; i++)
        {
            const csvEntry = CSV[i];
            this.remapCSVFields(csvEntry);
            this.handleGenericFields(csvEntry);
            // Add 'added' dates if needed/available for this entry
            if ( (blameData !== null || blameData !== undefined) && csvEntry.added === 0)
            {
                const blameLine = i-1;
                const blamed = blameData[blameLine];
                if(blamed && blamed['committer-time'])
                {
                    csvEntry.added = blamed['committer-time'];
                }
            }
        }
        printv(5,'Loaded CSV from '+entry.file);
        return CSV;
    }

    // Load git blame data for a file
    loadGitBlame(filePath)
    {
        let gitBlameOutput;
        try
        {
            gitBlameOutput = child_process.execFileSync('git',['blame','--line-porcelain','-w','--minimal','-C',filePath],{ stdio: [ 'ignore','pipe','ignore' ] });
        }
        catch(e)
        {
            printv(4,'Error during execFileSync of git blame: '+e.message);
            return [];
        }
        gitBlameOutput = gitBlameOutput.toString();
        gitBlameOutput = gitBlameOutput.split(/\n/);
        const blame = [];
        let current = {};
        for(let i = 0; i < gitBlameOutput.length; i++)
        {
            const line = gitBlameOutput[i];
            if (/^\t/.test(line))
            {
                blame.push(current);
                current = {};
            }
            else
            {
                const key = line.replace(/^(\S+)\s+.*/,'$1');
                const value = line.replace(/^\S+\s+/,'');
                current[key] = value;
            }
        }
        return blame;
    }

    // Placeholder method: Download metadata for an item
    // This MUST be overridden by subclasses
    //
    // eslint-disable-next-line no-unused-vars
    addMetadataTo(collItem)
    {
        throw('collectionType: generic addMetadataTo called: should be overridden by subclass');
    }

    // Placeholder method: Download the poster for an item
    // This MUST be overridden by subclasses
    //
    // eslint-disable-next-line no-unused-vars
    addPosterToItem(collItem)
    {
        throw('collectionType: generic addPosterToItem called: should be overridden by subclass');
    }

    /*
     * Finalize the collection.
     * This will add id-numbers and filter unused data
     */
    finalizeCollection(data)
    {
        data = this.sortFinalCollection(data);
        for (const collectionEntry of data)
        {
            collectionEntry.bSourceList = collectionEntry.bSource.split(/\s*,\s*/);
            this.filterUnusedDataFromEntry(collectionEntry);
        }
        return { data, 'meta':this.getFinalizedMetadata()};
    }

    // Removes extranious data from an entry
    filterUnusedDataFromEntry(entry)
    {
        const alwaysIncluded = {
            origTitle:true,
            title: true,
            year: true,
            bSource: true,
            bSourceList: true,
            altTitle: true,
            contentType:true,
            added: true,
            normalizedTitle: true,
            normalizedRating: true,
            addedRaw: true,
            sortYear: true,
            poster: true,
            plot: true,
            id: true,
            genre: true,
            note: true,
            type: true
        };
        if(this._includedEntryData && !commander.includeDebug)
        {
            for (const field in entry)
            {
                if (!this._includedEntryData[field] && !alwaysIncluded[field])
                {
                    delete entry[field];
                }
            }
        }
    }

    /*
     * Apply sorting to the collection
     */
    sortFinalCollection(data)
    {
        let sortMethod = 'alpha';
        let sortBy = 'title';
        if(this._entry.defaultSort !== undefined)
        {
            sortBy = this._entry.defaultSort;
        }
        if(sortBy === 'year')
        {
            sortMethod = 'numeric';
        }
        data.sort((a,b) =>
        {
            if(a[sortBy] !== undefined && b[sortBy] !== undefined && a[sortBy] !== b[sortBy])
            {
                if(sortMethod === 'alpha')
                {
                    return a[sortBy].localeCompare(b[sortBy]);
                }
                else if(sortMethod === 'numeric')
                {
                    return b[sortBy]- a[sortBy];
                }
                else
                {
                    throw('UNKNOWN sortMethod in sortFinalCollection: '+sortMethod);
                }
            }
            if(a[sortBy] && !b[sortBy])
            {
                return -1;
            }
            if (!a[sortBy] && b[sortBy])
            {
                return 1;
            }
            // Fallback to title comparison
            return a.title.localeCompare(b.title);
        });
        return data;
    }

    /*
     * Finalizes metadata. It deduplicates subarrays and removes
     * null/undefined entries
     */
    getFinalizedMetadata ()
    {
        for(const metaEntry in this._meta)
        {
            // Filter and deduplicate arrays
            if(Array.isArray(this._meta[metaEntry]))
            {
                // First, sort the array
                let result = this._meta[metaEntry];
                result.sort();
                // Ensure entries are unique
                result = _.uniq(result);
                // Ensure nothing is null or undefined
                result = _.filter(result,
                    (entry) =>
                    {
                        return entry !== null && entry !== undefined;
                    }
                );
                // Save our newly deduplicated and filtered array
                this._meta[metaEntry] = result;
            }
        }
        return this._meta;
    }

    // Adds "statically generated" metadata to an item. This includes the item
    // type and source
    addStaticMetadataToItem (collItem)
    {
        collItem.type    = this._entry.type;
        collItem.bSource = this._curBsource;
    }

    /*
     * Performs everything needed to prepare a single collection item.
     * It will add static metadata, dynamic metadata, store helper data for
     * the front-end and download a poster
     */
    generateEntry (collItem)
    {
        if(this._entry.contentType)
        {
            collItem.contentType = this._entry.contentType;
        }
        this.addStaticMetadataToItem(collItem);
        this.addMetadataTo(collItem);
        this.storeFieldBools(collItem);
        this.addPosterToItem(collItem);
    }

    /*
     * Generates a single source belonging to a collection
     */
    generateSource (source)
    {
        const data = this.loadData(source);
        let entryNumber = 0;
        for(const collItem of data)
        {
            entryNumber++;
            printv(10,'Processing collection entry '+entryNumber+' of '+data.length);
            this.generateEntry(collItem);
        }
        if(source.hasDisneySort)
        {
            this._meta.hasDisneySort = true;
        }
        cache.flushIfNeeded();
        return data;
    }

    // Perform all actions needed to get a full collection datastructure
    generateDatastructure ()
    {
        let entries = [];
        // Walk through all datasources and generate each one
        for(const source of this._entry.sources)
        {
            this._curSource = source;
            const contents = this.generateSource(source);
            source.bSource = this._curBsource;
            entries = entries.concat(contents);
        }
        return this.finalizeCollection(entries);
    }

    /*
     * Sets booleans for fields. Reads fields from "entry" and stashes it into
     * meta.fields.[]
     */
    storeFieldBools (entry)
    {
        for(const field in entry)
        {
            this._meta.fields[field] = true;
        }
    }

    /*
     * Convers thing into an array if it isn't already
     */
    mustBeArray(thing)
    {
        if (!Array.isArray(thing))
        {
            return [ thing ];
        }
        return thing;
    }

    /*
     * Converts thing to a string if it isn't already
     */
    mustBeString(thing)
    {
        if(thing === undefined)
        {
            return thing;
        }
        if (Array.isArray(thing))
        {
            return thing.join(', ');
        }
        if(typeof(thing) !== "string")
        {
            if(thing.toString)
            {
                return thing.toString();
            }
            throw('Unable to ensure that "'+thing+'" is a string');
        }
        return thing;
    }

    /*
     * Performs a HTTP request that returns XML and then converts it to a
     * JSON-style object.
     *
     */
    XMLtoJSONRequest(url)
    {
        const cached = cache.get('externalAPI',url);
        if(cached !== undefined)
        {
            return _.clone(cached,true);
        }
        if(commander.lazy)
        {
            printv(4,'XMLtoJSONRequest: skipping request due to --lazy');
            return;
        }
        printv(4,'Performing XMLtoJSONRequest to: '+url);
        let data;
        try
        {
            data = wait.forMethod(httpreq,'get',url);
        }
        catch(e)
        {
            printv(1,'Got error while performing an XMLtoJSONRequest to "'+url+'": '+e.message);
        }
        try
        {
            data = xml2json.toJson(data.body);
        }
        catch(e)
        {
            // Errors might mean malformed XML, just return nothing
            return;
        }
        const result = JSON.parse(data);
        cache.set(result,'externalAPI',url);
        return result;
    }

    /*
     * Downloads a poster for an entry
     */
    downloadPoster(url,entry)
    {
        if(!this.isValidCoverURL(url))
        {
            printv(1,'Failed to retrieve poster for '+entry.title+( entry.origTitle ? ' ('+entry.origTitle+')' : ''));
            return;
        }
        const type = url.replace(/.*\.([^\.]+)$/,'$1').replace(/\W.*/,'');
        const hash  = this._posterIdentifier(entry);
        const fname = hash+'.'+type;
        if (!fs.existsSync(helper.resolveOutPath('.rotcellocdata/images/orig/'+fname)))
        {
            if(commander.lazy)
            {
                printv(4,'downloadPoster: skipping download due to --lazy');
                return;
            }
            if (cache.existsNotMiss('posterFiles',url) && cache.get('posterFiles',url) === null)
            {
                return;
            }
            printv(4,'Downloading: '+url+' to .rotcellocdata/images/orig/'+fname);
            const data = wait.forMethod(httpreq,'get',url, {binary: true });
            if(data.statusCode === 200)
            {
                fs.writeFileSync(helper.resolveOutPath('.rotcellocdata/images/orig/'+fname),data.body);
                cache.set({ hash, type},'posterFiles',url);
                printv(1,'Downloaded poster for '+entry.title);
            }
            else
            {
                cache.set(null,'posterFiles',url);
                printv(1,'Failed to download poster from '+url+': '+data.statusCode);
                return;
            }
        }
        runtimeCache.postersUsed[fname] = true;
        return fname;
    }

    /*
     * Checks if a poster has been downloaded
     */
    hasPosterBeenDownloaded(entry)
    {
        const hash = this._posterIdentifier(entry);
        const files = wait.for(glob,helper.resolveOutPath('.rotcellocdata/images/orig/'+hash+'.*'));
        return files.length > 0;
    }

    /*
     * Retrieves the "poster" identifier for an entry
     */
    _posterIdentifier(entry)
    {
        // Generate an identifier
        let identifier = 'poster';
        // If we have a unique identifier already, use that
        if (entry.isbn || entry.steamID)
        {
            identifier += '-'+(entry.isbn || entry.steamID);
        }
        // Otherwise generate one from a set of fields that together should
        // uniquely identify an entry
        else
        {
            for(const idEntry of [ 'title','origTitle','altTitle','year','author','platform' ])
            {
                if(entry[idEntry] !== undefined && entry[idEntry] !== null)
                {
                    identifier += '-'+entry[idEntry];
                }
            }
        }
        identifier += '-'+this._curBsource;
        const hash = crypto.createHash('sha256').update(identifier).digest("hex");
        return hash;
    }

    /*
     * Retrieves the size of an image.
     * Returns undefined or an object with the keys width and height
     */
    imageSize(file)
    {
        const img = gm(file);
        return wait.forMethod(img,'size');
    }

    /*
     * Downloads a URL synchronously and returns the JSON data from it
     */
    GETJSON(url)
    {
        if(commander.lazy)
        {
            printv(4,'GETJSON: skipping download due to --lazy');
            return;
        }
        printv(4,'Performing GET request for JSON to '+url);
        let data;
        try
        {
            data = wait.forMethod(httpreq,'get',url);
        }
        catch(e)
        {
            printv(5,'Exception while performing request: '+e.message);
            return null;
        }
        if (data.body === 'null')
        {
            printv(5,'URL returned literal null');
            return;
        }
        try
        {
            const req = JSON.parse(data.body);
            printv(5,'Successfully parsed JSON');
            return req;
        }
        catch(e)
        {
            printv(5, 'Error during JSON parsing: '+e.message);
            return;
        }
    }

    /*
     * Remaps fields on an object (CSV-file) from various variations that we
     * accept into the actual fields we use internally
     */
    remapCSVFields(content)
    {
        // FIXME: This should be translateable in other languages
        const map = {
            'Tittel':'title',
            'Forfattar':'author',
            'Forfatter':'author',
            'Forlag':'publisher',
            'Namn':'title',
            'Plattform':'platform',
            'Sesongar':'seasons',
            'Sesonger':'seasons',
            'Original Tittel':'origTitle',
            'Original tittel':'origTitle',
            'Årstall':'year',
            'Sjanger':'genre',
            'Format':'format',
            'Klassikernummer':'disneyClassicNo',
            'Lagt til':'added',
            'Kover':'customCover',
            'Sett':'watched',
            'Cover':'customCover',
            'Skuespillere':'actors',
            'Omslag':'customCover',
            'Alternativ tittel':'altTitle',
            'Alternativ Tittel':'altTitle',
            'IMDB ID':'imdbID',
            'Rating':'rating',
            'Terningkast':'rating',
            'Språk':'language',
            'Notat':'note'
        };
        // Remap according to the mapping table
        for(const key in map)
        {
            let sourceKey = key;
            if(content[key] === undefined)
            {
                sourceKey += ':';
            }
            if(content[sourceKey] !== undefined)
            {
                if(content[sourceKey].length)
                {
                    content[ map[key] ] = content[sourceKey];
                }
                delete content[sourceKey];
            }
        }
        // Lowercase unmapped keys
        for(const key in content)
        {
            if(key === "")
            {
                printv(1,'Warning: '+content.title+' has an empty key ("")');
                continue;
            }
            if (/^[A-Z]/.test(key))
            {
                content[key.toLowerCase()] = content[key];
                delete content[key];
            }
        }
    }

    /*
     * Parses and sets the "added" field
     */
    handleGenericFields(content)
    {
        if(content.added)
        {
            content.addedRaw = content.added;
            content.added = Math.round(Date.parse(content.added)/1000);
        }
        else
        {
            content.added = 0;
        }
    }

    /*
     * Does some generic replacements on a title, converting roman numerals to
     * the Arabic numerals (and the other way around), and converting & to and
     * or and to &
     */
    attemptGenericReplacements(origTitle)
    {
        if(origTitle === null || origTitle === undefined)
        {
            throw('attemptGenericReplacements got null origTitle');
        }
        const replacements = [
            {
                index: 'III',
                replacement: '3',
                regex: /III/
            },
            {
                index: '3',
                replacement: 'III',
                regex: /3/
            },
            {
                index: 'II',
                replacement: '2',
                regex: /II/
            },
            {
                index: '2',
                replacement: 'II',
                regex: /2/
            },
            {
                index: 'IV',
                replacement: '4',
                regex: /IV/
            },
            {
                index: '4',
                replacement: 'IV',
                regex: /4/
            },
            {
                index: ' and ',
                replacement: ' & ',
                regex: / and /
            },
            {
                index: ' & ',
                replacement: ' and ',
                regex: / & /
            },
            {
                index: ' 1:',
                replacement: ' I:',
                regex: / 1:/
            },
            {
                index: 'two',
                replacement: '2',
            },
            {
                index: 'three',
                replacement: '3',
            },
            {
                index: 'four',
                replacement: '4',
            },
            {
                index: 'five',
                replacement: '5',
            },
        ];
        for (const attempt of replacements)
        {
            if(origTitle.indexOf(attempt.index) !== -1)
            {
                return origTitle.replace(attempt.regex,attempt.replacement);
            }
        }
        return null;
    }

    /*
     * Performs some simple replacements to remove entities from a title
     * that obviously isn't suppose to be there
     */
    normalizeTitle(origTitle)
    {
        return origTitle.replace(/\s*™/,'');
    }

    /*
     * Checks if url is a valid url to a cover
     */
    isValidCoverURL(url)
    {
        if (url === null || url === undefined || !/^http/.test(url) || /originalnull/i.test(url))
        {
            return false;
        }
        return true;
    }

    /*
     * Parse a boolean-ish string
     */
    parseBool(boolStr)
    {
        boolStr = boolStr.toLowerCase();
        // Translators: Used in boolean values in files
        if(boolStr === 1 || boolStr === 'true' || boolStr === 'yes' || boolStr === i18n.translate('Yes').toLowerCase())
        {
            return true;
        }
        // Translators: Used in boolean values in files
        else if(boolStr === 0 || boolStr === 'false' || boolStr === 'no' || boolStr === i18n.translate('No').toLowerCase())
        {
            return false;
        }
        else
        {
            throw('Unrecognized boolean value: '+boolStr);
        }
    }
}

/*
 * This is the API that generates the collection with metadata and posters for
 * a movie and/or TV series collection
 */
class movieCollection extends collectionType
{
    // Parent constructor will call initialize for us after it has done the construction
    initialize ()
    {
        Object.assign(this._meta,
        {
            genres: [],
            formats: [],
            enableNormalized: false,
            fields: {}
        });
        this._includedEntryData = {
            actors: true,
            metascore: true,
            imdbRating: true,
            imdbVotes: true,
            director: true,
            writer: true,
            genre: true,
            runtime: true,
            runtimeMin:true,
            seasons: true,
            format: true,
            rating: true,
            disneyClassicNo: true,
            imdbID: true,
            watched: true,
        };
    }

    // Adds a poster to a collection entry
    addPosterToItem (collectionEntry)
    {
        const theFname   = this.getPoster(collectionEntry);
        if(!theFname)
        {
            collectionEntry.poster = undefined;
            return;
        }
        collectionEntry.poster = encodeURIComponent(theFname);
    }

    // Finds and downloads a poster for the provided entry
    getPoster (entry)
    {
        let url;
        let mTitle = entry.title;
        let source;
        let posterMeta = {};
        const posterCkey = 'poster:'+getCacheID(entry);
        if(cache.exists('meta',posterCkey))
        {
            posterMeta = cache.get('meta',posterCkey);
        }
        // origTitle is usually much more consistent for fetching posters, so use
        // that if available
        if(entry.origTitle)
        {
            mTitle = entry.origTitle;
        }
        // Support custom covers
        if(entry.customCover)
        {
            url = entry.customCover;
            delete entry.customCover;
            source = 'custom';
        }
        else
        {
            // Use OMDB if we can
            if(!this.isValidCoverURL(url) && entry.imdbID && entry.poster)
            {
                url = entry.poster;
                source = 'OMDB';
            }
            // Fall back to movieArt if OMDB can't provide data
            if (!this.isValidCoverURL(url))
            {
                url = this.getPosterFromMovieArt(entry,mTitle);
                source = 'movieArt';
            }
            // Give up
            if (!this.isValidCoverURL(url))
            {
                printv(5,'Failed to find a cover for '+entry.title);
                return;
            }
        }
        // Download poster
        let fname = this.downloadPoster(url,entry);
        // Now, if the poster was from OMDB we want to make sure that it is a good one.
        // Sometimes OMDB has low-res posters, and in these cases movieArt will often
        // return a nicer poster. Thus we try to fetch one from movieArt and see if that
        // is better. We only do this once.
        if(fname !== undefined && source === 'OMDB' && !posterMeta.triedMovieArt)
        {
            // This is the path the current poster is saved to
            const fullPath = helper.resolveOutPath('.rotcellocdata/images/orig/'+fname);
            // The dimensions of the current poster
            const omdbFsize = this.imageSize(fullPath);
            // Only try movieArt if the current poster is bad
            if(omdbFsize.width < 270 || omdbFsize.height < 380)
            {
                printv(1,'Poster for "'+mTitle+'" was of poor quality, trying to find better poster with movieArt...');
                // Try to get a poster from movieArt
                const movieArtUrl = this.getPosterFromMovieArt(entry,mTitle);
                // If movieArt had a poster, try to process that
                if (movieArtUrl !== undefined)
                {
                    const origFname = fname;
                    let useMovieArt = false;
                    let movieArtFullPath;
                    // Rename the old poster so that if it turns out that movieArt isn't better
                    // we don't bother re-downloading the original
                    fs.renameSync(fullPath,fullPath+'~');
                    // Download the movieArt poster
                    fname = this.downloadPoster(movieArtUrl,entry);
                    // If we got a movieArt poster
                    if(fname !== undefined)
                    {
                        movieArtFullPath = helper.resolveOutPath('.rotcellocdata/images/orig/'+fname);
                        const movieArtSize = this.imageSize(movieArtFullPath);
                        // Check if it is better than the OMDB one, if it is, we use it
                        if( (movieArtSize.width > omdbFsize.width) || (movieArtSize.height > omdbFsize.height) )
                        {
                            useMovieArt = true;
                        }
                    }
                    // If we were told to use movieArt, output a message about it and
                    // delete the old OMDB poster
                    if(useMovieArt)
                    {
                        printv(2,'Found a better poster using movieArt, using that');
                        fs.unlinkSync(fullPath+'~');
                    }
                    // If we're not using movieArt, move the previous poster back into
                    // place and remove the one from movieArt
                    else
                    {
                        printv(2,'movieArt did not return a better poster, using the previous one');
                        fs.unlinkSync(movieArtFullPath);
                        fs.renameSync(fullPath+'~',fullPath);
                        fname = origFname;
                    }
                }
            }
            // Store that we've tried movieArt in the cache so we don't try it
            // again later
            posterMeta.triedMovieArt = true;
            cache.set(posterMeta,'meta',posterCkey);
        }
        return fname;
    }

    getPosterFromMovieArt(entry,mTitle)
    {
        let url;
        let type = entry.type;
        // Remap type so that movieArt can handle it
        if(type === 'movies')
        {
            type = 'movie';
        }
        else if(type === 'series')
        {
            type = 'tv';
        }
        // Try to fetch with a year value first
        if(!this.isValidCoverURL(url) && entry.year)
        {
            url = this.submitMovieArtRequest(mTitle,entry.year,type);
        }
        // Fall back to only using the title
        if(!this.isValidCoverURL(url))
        {
            url = this.submitMovieArtRequest(mTitle,null,type);
        }
        if(!this.isValidCoverURL(url))
        {
            // Try to see if we can find something if we switch the types
            // around
            if(type === 'tv')
            {
                type = 'movie';
            }
            else
            {
                type = 'tv';
            }
            if(entry.year && !url)
            {
                url = this.submitMovieArtRequest(mTitle,entry.year,type);
            }
            if(!this.isValidCoverURL(url))
            {
                url = this.submitMovieArtRequest(mTitle,null,type);
            }
            if(!this.isValidCoverURL(url) && entry.poster)
            {
                url = entry.poster;
            }
        }
        return url;
    }

    // Submits a movieArt request
    submitMovieArtRequest (mTitle,year,type)
    {
        let url;
        const identifier = 'movieArt::'+mTitle+','+year+','+type;
        const cached = cache.get('externalAPI',identifier);
        if(cached !== undefined)
        {
            return cached;
        }
        printv(5,'Submitting request to movieArt: '+mTitle+','+year+','+type);
        try
        {
            url = wait.for(movieArt,mTitle,year,null,type);
        }
        catch(e)
        {
            // Ignore errors, url will be undefined which is fine
        }
        cache.set(url,'externalAPI',identifier);
        return url;
    }

    // Adds metadata to an entry
    addMetadataTo(collectionEntry)
    {
        // We rely upon the title to locate metadata
        if(collectionEntry.title === null || collectionEntry.title === undefined || !/\S/.test(collectionEntry.title))
        {
            printv('Entry "'+JSON.stringify(collectionEntry)+'": has no "title" - skipping it');
            return;
        }
        // Parse the "watched" field if needed
        if(collectionEntry.watched !== null && collectionEntry.watched !== undefined)
        {
            collectionEntry.watched      = this.parseBool(collectionEntry.watched);
        }

        // Download the metadata
        const meta = this.retrieveMetadataFor(collectionEntry);
        if(meta !== null && meta !== undefined)
        {
            const genericRemapping = {
                imdbID: 'imdbID',
                Actors: 'actors',
                Metascore: 'metascore',
                imdbRating: 'imdbRating',
                imdbVotes: 'imdbVotes',
                Plot: 'plot',
                Director:'director',
                Year: 'year',
                // This *will* get overridden by addPosterToItem(). It is used
                // so that we can provide a poster URL hint to getPoster().
                Poster: 'poster',
            };
            for(const fromField in genericRemapping)
            {
                const toField = genericRemapping[fromField];
                if(collectionEntry[fromField] === undefined && this.isValidOMDBField(meta[fromField]))
                {
                    collectionEntry[toField] = meta[fromField];
                }
            }
            if(this.isValidOMDBField(meta.Writer))
            {
                // Translators: used to translate substrings in the «writer» metadata
                collectionEntry.writer = meta.Writer.replace(/screenplay/g,i18n.translate('screenplay'))
                // Translators: used to translate substrings in the «writer» metadata
                .replace(/(motion picture|movie)/g,i18n.translate('motion picture'))
                // Translators: used to translate substrings in the «writer» metadata
                .replace(/comic( book)?/g,i18n.translate('comic book'))
                // Translators: used to translate substrings in the «writer» metadata
                .replace(/story/g,i18n.translate('story'))
                // Translators: used to translate substrings in the «writer» metadata
                .replace(/novel/g,i18n.translate('novel'))
                // Translators: used to translate substrings in the «writer» metadata
                .replace(/characters/g,i18n.translate('characters'))
                // Translators: used to translate substrings in the «writer» metadata
                .replace(/book/g,i18n.translate('book'));
            }
            if (this._curSource.autoGenre &&!collectionEntry.genre && this.isValidOMDBField(meta.Genre))
            {
                collectionEntry.genre = meta.Genre;
            }
            if(this.isValidOMDBField(meta.Runtime))
            {
                let runtime = meta.Runtime;
                if (/ min/.test(runtime))
                {
                    runtime                    = runtime.replace(/\s+min/,'');
                    collectionEntry.runtimeMin = runtime;
                    const floating               = parseInt(runtime)/60;
                    if(floating > 0)
                    {
                        const hours   = parseInt(floating);
                        const minutes = parseInt((floating-hours)*60);
                        if(hours > 0)
                        {
                            // Translators: Results in [number]h [number]min (ie. X hours and X minutes)
                            runtime = util.format(i18n.translate('%dh %dmin'),hours,minutes);
                        }
                        else
                        {
                            // Translators: Results in [number]min (ie. X minutes)
                            runtime = util.format(i18n.translate('%dmin'),minutes);
                        }
                    }
                }
                collectionEntry.runtime = runtime;
            }
        }
        if(collectionEntry.genre)
        {
            this._meta.genres = this._meta.genres.concat(collectionEntry.genre.split(/,\s*/));
        }
        if(collectionEntry.format)
        {
            collectionEntry.format = collectionEntry.format.split(/,\s*/);
            this._meta.formats = this._meta.formats.concat(collectionEntry.format);
        }
        if(collectionEntry.rating)
        {
            this._meta.enableNormalized   = true;
            if(collectionEntry.rating > 6 || collectionEntry.rating < 1)
            {
                printv(1,'Unreasonable rating for "'.collectionEntry.title+'": '+collectionEntry.rating+' (should be 1-6)');
            }
            else
            {
                collectionEntry.normalizedRating = parseInt(collectionEntry.rating*16.7);
                if(collectionEntry.imdbRating)
                {
                    const decimal = parseInt(collectionEntry.imdbRating*10);
                    collectionEntry.normalizedRating = parseFloat(collectionEntry.normalizedRating+'.'+decimal);
                }
            }
        }
        else if(collectionEntry.imdbRating)
        {
            collectionEntry.normalizedRating = parseInt(collectionEntry.imdbRating*10);
        }
        else if(collectionEntry.metascore)
        {
            collectionEntry.normalizedRating = collectionEntry.metascore;
            this._meta.enableNormalized   = true;
        }
        if(collectionEntry.year)
        {
            collectionEntry.sortYear = parseInt(collectionEntry.year);
        }
        collectionEntry.normalizedTitle = this.normalizeTitle( collectionEntry.origTitle ? collectionEntry.origTitle : collectionEntry.title );
    }

    // Fetches metadata from a source for an entry
    retrieveMetadataFor(entry)
    {
        const ckey = getCacheID(entry);
        if(cache.existsNotMiss('meta',ckey))
        {
            return cache.get('meta',ckey);
        }
        const data = this.fetchFromOMDB(entry);
        if(data && data.Response === "False")
        {
            printv(3,'Could not retrieve data from OMDB on '+ (entry.origTitle ? entry.origTitle : entry.title) );
            cache.set(null,'meta',ckey);
            return;
        }
        if ((entry.type === 'movies' && (!entry.year || parseInt(entry.year) === parseInt(data.Year)))|| (entry.type === 'series' || parseInt(entry.year) === parseInt(data.Year)) || (entry.imdbID && data.imdbID === entry.imdbID) )
        {
            printv(1,'Fetched meta info for '+entry.title);
            cache.set(data,'meta',ckey);
            return data;
        }
        else
        {
            if(entry.year && data.Year !== entry.year)
            {
                const diff = entry.year - data.Year;
                if (diff <= 2 && diff >= -2)
                {
                    printv(1,'Discrepancy: '+entry.title+' is marked as released in '+entry.year+' but the OMDB entry claims '+data.Year+' (very similar): ignoring data from server');
                }
                else
                {
                    printv(1,'Discrepancy: '+entry.title+' is marked as released in '+entry.year+' but the OMDB entry claims '+data.Year+': ignoring data from server');
                }
            }
            cache.set(null,'meta',ckey);
        }
        return;
    }

    /*
     * Downloads data from OMDB and attempts fuzzier searches if no data is
     * found
     */
    fetchFromOMDB(entry)
    {
        let data;
        try
        {
            data = wait.for(this.performOMDBRequest,entry);
        }
        catch(e)
        {
            data = null;
        }
        if(data && data.Response !== "False")
        {
            return data;
        }
        if(entry.imdbID)
        {
            // Try a request without imdbID
            data = wait.for(this.performOMDBRequest,{ title: entry.origTitle ? entry.origTitle : entry.title, year: entry.year, type: entry.type });
        }
        if(data && data.Response !== "False")
        {
            return data;
        }
        if(entry.origTitle)
        {
            // Try a request without origTitle
            data = wait.for(this.performOMDBRequest,{ title: entry.title, year: entry.year, type: entry.type });
        }
        if(data && data.Response !== "False")
        {
            return data;
        }
        if(entry.altTitle)
        {
            data = wait.for(this.performOMDBRequest,{ title: entry.altTitle, type: entry.type });
        }
        if(data && data.Response !== "False")
        {
            return data;
        }
        if(entry.year)
        {
            data = wait.for(this.performOMDBRequest,{ title: entry.origTitle ? entry.origTitle : entry.title, type: entry.type });
        }
        if(data && data.Response !== "False")
        {
            return data;
        }
        if(entry.type)
        {
            const entryWithoutType = _.cloneDeep(entry);
            delete entryWithoutType.type;
            return this.fetchFromOMDB(entryWithoutType);
        }

        const fixedTitle = this.attemptGenericReplacements(entry.origTitle ? entry.origTitle : entry.title);
        if(fixedTitle)
        {
            data = wait.for(this.performOMDBRequest,{ title: fixedTitle, year: entry.year });
        }

        return data;
    }

    /*
     * Constructs and submits a single OMDB request
     */
    performOMDBRequest(titleData,cb)
    {
        const url          = 'http://www.omdbapi.com',
            requestQuery = {t: titleData.title, plot: 'short', r: 'json'};
        if(titleData.imdbID)
        {
            delete requestQuery.t;
            requestQuery.i = titleData.imdbID;
        }
        else
        {
            if(titleData.origTitle)
            {
                requestQuery.t = titleData.origTitle;
            }
            if(titleData.year)
            {
                requestQuery.y = parseInt(titleData.year);
            }
            if(titleData.type === 'series')
            {
                requestQuery.type = 'series';
            }
        }
        if( (requestQuery.t === null || requestQuery.t === undefined) && (requestQuery.i === null || requestQuery.i === undefined))
        {
            return cb('t+i are null');
        }
        const serialish = url+JSON.stringify(requestQuery);
        const cached = cache.get('externalAPI',serialish);
        if(cached !== undefined)
        {
            cb(null,_.clone(cached,true));
            return;
        }
        printv(4,'Performing OMDB request: '+ (requestQuery.t ? requestQuery.t : requestQuery.i ));
        printv(8,'Request key: '+serialish);
        httpreq.get(url, {
                parameters: requestQuery
            },(err,res) =>
            {
                if (!err)
                {
                    try
                    {
                        res = JSON.parse(res.body);
                        cache.set(res,'externalAPI',serialish);
                    }
                    catch(e)
                    {
                        err = e;
                    }
                }
                cb(err,res);
            }
        );
    }

    /*
     * Checks if a field from OMDB is valid (they can be undefined or the
     * string 'N/A' if invalid)
     */
    isValidOMDBField (content)
    {
        if(content !== undefined && content !== 'N/A')
        {
            return true;
        }
        return false;
    }
}

/*
 * This is the API that generates the collection with metadata and posters for
 * a video game collection
 */
class gameCollection extends collectionType
{
    // Parent constructor will call initialize for us after it has done the construction
    initialize ()
    {
        this._steamAPIErrLimitReached = false;
        Object.assign(this._meta,
        {
            genres: [],
            platforms: [],
            fields: {}
        });
    }

    // Overrides the loadData() method, because games have a special "steam" source
    loadData(source)
    {
        if(source.source && source.source === 'steam')
        {
            return this.loadSteamData(source);
        }
        else
        {
            return this.loadCSVData(source);
        }
    }

    // Loads Steam data
    loadSteamData(source)
    {
        const user = source.user,
            ckey = 'steam//games//'+user,
            now  = Math.floor(Date.now() / 1000);
        this._curBsource = 'steam/'+user;
        printv(3,'Interpreting steam collection for "'+user+'"');
        if(cache.get('arbitrary',ckey))
        {

            const lastUpdated = cache.get('arbitrary',ckey+'//_lastUpdated');
            if(lastUpdated !== undefined && lastUpdated > (now - (82800*7) ) && !commander.forceSteamUpdate)
            {
                printv(5,'Using cached Steam data for '+user);
                return cache.get('arbitrary',ckey);
            }
            else
            {
                printv(2,'Updating Steam data for '+user);
            }
        }
        const data = wait.for(steam.gamesFromProfile,user),
            resultData = [];
        for(const entry of data)
        {
			if (
				// Ignore DLC and season passes
				/\s(DLC|[Ss]eason\s+[Pp]ass)/.test(entry.title) ||
				// Other DLC matches
				/\s((Map|Texture)\s*Pack)(\s*\d*)?$/.test(entry.title) ||
				// Ignore games returned from Steam with completely wrong
				// names
				/^\s*(Limited\s*Edition)\s*$/i.test(entry.title)
			)
            {
                continue;
            }

            entry.steamUser = user;
            entry.title    = entry.name;
            entry.steamID  = entry.appid;
            entry.format   = 'Steam';
            resultData.push(entry);
        }
        this.retrieveSteamMetadata(data,user);
        cache.set(now,'arbitrary',ckey+'//_lastUpdated');
        cache.set(resultData,'arbitrary',ckey);
        return resultData;
    }

    /*
     * Fetches some deep keys if they are available, or undefined if it
     * can not be found. Also returns data in a specified format
     */
    deepFetch(type, source, rabbitHole)
    {
        for(const entry of rabbitHole)
        {
            if(source !== null && source[entry])
            {
                source = source[entry];
            }
            else
            {
                source = null;
                break;
            }
        }
        if(type === 'array')
        {
            return this.mustBeArray(source);
        }
        throw('Unhandled type: '+type);
    }

    /*
     * Handles metadata preparation and mapping for *any* game
     */
    addMetadataTo(collItem)
    {
        const meta = this.getGameMetadata(collItem);
        if(meta)
        {
            let genres = [];
            if(collItem.genres)
            {
                genres = collItem.genres.split(/,s\*/);
            }
            else if(meta.steamGenres)
            {
                for(const genre of meta.steamGenres)
                {
                    genres.push(genre.description);
                }
            }
            else
            {
                genres = this.deepFetch('array',meta,['Genres','genre']);
            }
            if (collItem.year)
            {
                collItem.sortYear = parseInt(collItem.year);
            }
            else if(meta.ReleaseDate)
            {
                collItem.year = meta.ReleaseDate.split('/')[2];
                collItem.sortYear = collItem.year;
            }
            else if(meta.steamRelDate)
            {
                collItem.Year = meta.steamRelDate.date.replace(/^\S+\s+\S+\s+/,'');
                collItem.sortYear = collItem.year;
            }
            collItem.genre        = genres.join(', ');
            if(meta.steamOverview)
            {
                collItem.plot         = this.plotCleanAndLimit(collItem.steamOverview);
                if(!collItem.plot || collItem.plot.length === 0 || !/\S/.test(collItem.plot))
                {
                    collItem.plot = null;
                }
            }
            if (!collItem.platform && meta.steamPlatforms)
            {
                collItem.platform = meta.steamPlatforms;
            }
            if (!collItem.plot)
            {
                collItem.plot         = this.plotCleanAndLimit(meta.Overview);
            }
            if (!collItem.developer)
            {
                collItem.developer    = this.mustBeString(meta.Developer);
            }
            collItem.tgdbID       = meta.id;
            if(meta.metacritic !== null && meta.metacritic !== undefined && meta.metacritic.score !== null && meta.metacritic.score !== undefined)
            {
                collItem.metascore = meta.metacritic.score;
            }
            this._meta.platforms = this._meta.platforms.concat(collItem.platform);
            this._meta.genres = this._meta.genres.concat(genres);
        }
        if (!Array.isArray(collItem.platform))
        {
            collItem.platform = [ this.doPlatformRemap(collItem.platform,true) ];
        }
        collItem.poster   = this.getPosterURLFromData(collItem,meta);
        collItem.type     = 'game';
        collItem.normalizedTitle = this.performNameReplacements(this.normalizeTitle( collItem.origTitle ? collItem.origTitle : collItem.title ));
    }

    // Adds a poster to a collection entry
    addPosterToItem (collectionEntry)
    {
        if(collectionEntry.poster)
        {
            collectionEntry.poster = this.downloadPoster(collectionEntry.poster,collectionEntry);
        }
    }

    getPosterURLFromData(collectionItem,metadata)
    {
        try
        {
            if(metadata === undefined || metadata === null)
            {
                metadata = {};
            }
            let image;
            if(metadata.GameTitle)
            {
                metadata.title = metadata.GameTitle;
            }
            else if(collectionItem.title)
            {
                metadata.title = collectionItem.title;
            }
            if(metadata && metadata.Images && metadata.Images.boxart)
            {
                const iter = this.mustBeArray(metadata.Images.boxart);
                for (const img of iter)
                {
                    image = img.$t;
                    if(img.side === 'front')
                    {
                        break;
                    }
                }
                if(image && metadata.baseImgUrl)
                {
                    image = metadata.baseImgUrl+image;
                }
            }
            else if(metadata && metadata.header_image)
            {
                image = metadata.header_image;
            }
            else if(collectionItem && collectionItem.appid)
            {
                image = collectionItem.logo;
            }
            return image;
        }
        catch (e)
        {
            if(e.stack)
            {
                printv(1,'Error while finding poster for '+metadata.title+': '+e.stack);
            }
            else
            {
                printv(1,'Error while finding poster for '+metadata.title+': '+e);
            }
        }
        return;
    }

    // We override finalizeCollection so that we can deduplicate our list
    // Parent's finalizeCollection is still used as well
    finalizeCollection(data)
    {
        const seen = {};
        const finalEntries = [];
        // Deduplicate
        for (const collectionEntry of data)
        {
            const ckey = getCacheID(collectionEntry);
            if(seen[ckey] === undefined)
            {
                seen[ckey] = collectionEntry;
                finalEntries.push(collectionEntry);
            }
            else
            {
                seen[ckey].bSource += ', '+collectionEntry.bSource;
            }
        }
        return super.finalizeCollection(finalEntries);
    }

    /*
     * Downloads metadata about games from Steam
     *
     * FIXME: This function really shouldn't exist. The logic should all be
     * handled by getGameInfoFromSteam, including making the requests. That
     * will reduce the load on Steam (we will spend longer between requests),
     * and will make the code more self-contained. We can just store our rate
     * limiting as an attribute on the class instead of in the function.
     */
    retrieveSteamMetadata(games,name)
    {
        let apiLimiter = 0,
            errLimit   = 0,
            steamSleep = 30,
            messagePrinted = false,
            downloaded = 0;
        if(this._steamAPIErrLimitReached)
        {
            return;
        }
        for(let i = 0; i < games.length; i++)
        {
            const appid = games[i].appid;
            if(cache.get('steamMeta',appid) === undefined)
            {
                if (!messagePrinted)
                {
                    printv(1,'Now performing Steam queries for '+name+'. This can take a long time the first time it happens');
                    messagePrinted = true;
                }
                apiLimiter++;
                if(apiLimiter >= 30)
                {
                    apiLimiter = 0;
                    printv(2,'Sleeping 10 seconds to avoid Steam API limits.');
                    printv(1,'Status: processed '+ (i + 1)+' of '+games.length+' games for '+name);
                    cache.flushIfNeeded();
                    helper.sleep(10);
                }
                const data = this.GETJSON('http://store.steampowered.com/api/appdetails?appids='+appid+'&filters=basic,developers,genres,metacritic,platforms,controller_support,release_date');
                if(data)
                {
                    downloaded++;
                    errLimit = 0;
                    if(data[appid].success)
                    {
                        cache.set(data[appid].data,'steamMeta',appid);
                    }
                    else
                    {
                        cache.set(null,'steamMeta',null);
                    }
                }
                else
                {
                    errLimit++;
                    i--;
                    cache.flushIfNeeded();
                    if(errLimit > 5)
                    {
                        printv(1,'Aborting Steam retrieval for now, error limit exceeded.');
                        printv(1,'This can happen from time to time due to request limits on Steam.');
                        printv(1,'Try again a bit later.');
                        this._steamAPIErrLimitReached = true;
                        return;
                    }
                    printv(1,'Sleeping '+steamSleep+' seconds to allow the Steam API limits to reset [retry '+errLimit+' of 5]');
                    helper.sleep(steamSleep);
                    if(steamSleep < 120)
                    {
                        steamSleep += 30;
                    }
                    else
                    {
                        steamSleep += 10;
                    }
                }
            }
        }
        if(downloaded > 0)
        {
            printv(2,'Steam fetching done for '+name);
        }
    }

    /*
     * Returns Steam metadata if it exists
     */
    getGameInfoFromSteam(game)
    {
        return cache.get('steamMeta',game.steamID);
    }

    /*
     * Remaps game platform names, either to pretty versions or to the versions
     * used by TheGamesDB
     */
    doPlatformRemap(platform,pretty)
    {
        if(Array.isArray(platform))
        {
            const result = [];
            for (const entry of platform)
            {
                result.push( this.doPlatformRemap(entry) );
            }
            return result;
        }
        let platforms = {
            'playstation 2':'Sony Playstation 2',
            'playstation 3':'Sony Playstation 3',
            'playstation 4':'Sony Playstation 4',
            'playstation':'Sony Playstation',
            'wii':'Nintendo Wii',
            'gamecube':'Nintendo GameCube',
            'psx':'Sony Playstation',
            'ps1':'Sony Playstation',
            'ps2':'Sony Playstation 2',
            'ps3':'Sony Playstation 3',
            'ps4':'Sony Playstation 4',
            'psp':'Sony PSP',
            'vita':'Sony Playstation Vita',
            'psvita':'Sony Playstation Vita',
            'n64':'Nintendo 64',
            // Yes, this hurts me as well, but it's, sadly, needed
            'windows':'PC',
            'linux':'PC',
            'mac':'PC',
            'steam':'PC',
            'origin':'PC',
            'gog':'PC',
            'pce':'TurboGrafx 16',
            'tg16':'TurboGrafx 16',
            'tg-16':'TurboGrafx 16',
            'nes':'Nintendo Entertainment System (NES)',
            'snes':'Super Nintendo (SNES)',
            'super nintendo':'Super Nintendo (SNES)',
            'nintendo entertainment system':'Nintendo Entertainment System (NES)',
            'smd':'Sega Mega Drive',
        };
        if(pretty)
        {
            platforms = {
                'playstation 2':'PS2',
                'playstation 3':'PS3',
                'sony playstation 2':'PS2',
                'sony playstation 3':'PS3',
                'sony playstation 4':'PS4',
                'sony playstation vita':'PSVita',
                'nintendo entertainment system (nes)':'NES',
                'sony psp':'PSP',
                'playstation':'PS1',
                'sony playstation':'PS1',
                'nintendo wii':'Wii',
                'nintendo 64':'N64',
                'nintendo gamecube':'GameCube',
                'turbografx 16':'TG-16',
                'pce':'TG-16',
                'super nintendo (snes)':'SNES',
                'sega mega drive':'SMD',
            };
        }
        if(platform !== null && platform !== undefined)
        {
            const platLower = platform.toLowerCase();
            if(platforms[platLower])
            {
                return platforms[platLower];
            }
        }
        return platform;
    }

    /*
     * Downloads and merges metadata from TheGamesDB and SteamDB
     */
    getGameMetadata(game)
    {
        let baseMeta = this.getGameInfoFromTGD(game);
        if(game.steamID)
        {
            if(baseMeta === null || baseMeta === undefined)
            {
                baseMeta = {};
            }
            const steamMeta = this.getGameInfoFromSteam(game);
            if(steamMeta)
            {
                baseMeta.steamOverview = steamMeta.about_the_game;
                baseMeta.header_image  = steamMeta.header_image;
                baseMeta.metacritic    = steamMeta.metacritic;
                baseMeta.Developer     = steamMeta.developers;
                baseMeta.steamRelDate  = steamMeta.release_date;
                baseMeta.steamGenres   = steamMeta.genres;
                baseMeta.platforms     = steamMeta.platforms;
                baseMeta.steamID       = steamMeta.steam_appid;
                baseMeta.steamPlatforms = [];
                if(steamMeta.platforms)
                {
                    if(steamMeta.platforms.linux)
                    {
                        baseMeta.steamPlatforms.push('Linux');
                    }
                    if(steamMeta.platforms.windows)
                    {
                        baseMeta.steamPlatforms.push('Windows');
                    }
                    if(steamMeta.platforms.mac)
                    {
                        baseMeta.steamPlatforms.push('Mac');
                    }
                }
                else
                {
                    baseMeta.steamPlatforms.push('Windows');
                }
                if(baseMeta.Platform !== 'PC')
                {
                    baseMeta.Platform = 'PC';
                    // Disable use of images about games on other platforms
                    if(steamMeta.header_image)
                    {
                        delete baseMeta.Images;
                    }
                }
            }
        }
        return baseMeta;
    }

    /*
     * Cleans up (by parsing html entities) and limits the length of a plot
     */
    plotCleanAndLimit (plot)
    {
        if(plot !== undefined)
        {
            // The double decode here is intentional, Steam's data is oddly
            // double-encoded
            plot = he.decode(he.decode(plot.replace(/<[uo]l[^>]+>/g,"\n- ").replace(/([^\.\!\,])<\/[uo]l>/g,'$1.').replace(/<br\s*\/?>/g,"\n").replace(/<[^>]+>/g,'')));
            if(plot.length >= 200)
            {
                plot = plot.replace(/\n\n/,'. ');
                const split = plot.split(" ");
                plot = '';
                let currentSentence = [];
                for(const comp of split)
                {
                    currentSentence.push(comp);
                    if (/[\?\!\.]$/.test(comp))
                    {
                        if(plot.length > 0)
                        {
                            plot += ' ';
                        }
                        plot += currentSentence.join(' ');
                        if(plot.length > 200)
                        {
                            break;
                        }
                        currentSentence = [];
                    }
                }
                return plot+' [...]';
            }
        }
        return plot;
    }

    /*
     * Cleans up a game name, removing various markers that can prevent
     * us finding it in the metadata database, like "GOTY", "Remastered",
     * "Premium", "HD", "Director's cut", "early access", "for [platform]"
     * and so on. This gets triggered if retrieval of the full name fails.
     */
    performNameReplacements(on,doAll,excludeGeneric)
    {
        const orig = on;
        on = on.replace(/([:-]?\s*)\(?((the|steam|new|old)\s+)?(Black|Steam|Linux|Windows|Mac(\s*OS\s*X?)?|EU|PAL|NTSC|US|PS\s*Vita|Special|Collector[`’']?s?|Remastered|Game of the year|Complete|Enhanced|Ultimate|Gold|Extreme|Epic|Uber|Deluxe|Premium|HD|GOTY|Developer|Director|Final|Special|Ultimate|Extended|Anniversary)(\s+\S+)?\s+(journey|edition|version|cut|collection)\)?\s*(upgrade)?/ig,'')
            .replace(/\s*for\s*(Linux|Windows|Mac|PC)/i,'')
            .replace(/\s*(Linux|Windows|Mac|PC|Playstation|Playstation Vita|PS\s*Vita)\s*(Edition|Version)?$/i,'')
            .replace(/GOTY/,'')
            .replace(/[:-]?\s*(Classic|(Un)?stable|(Beta|Alpha)(\s*test)?|Deluxe|Gold|Linux|Mac(\s*OS\s*X?)?|Windows|Redux|Remaster(ed)?|HD|Complete|Trilogy|Collection)\s*$/gi,'')
            .replace(/[:-]?\s*(Single|Multi)\s*player/gi,'')
            .replace(/\([^\)]+\)/,'')
            .replace(/Sid Meier\'s\s*/gi,'')
            .replace(/\+/g,'')
            .replace(/[:-]?\s*(Ep(isode)?|Chapter)\s*\d+.*/,'')
            .replace(/\s*Early\s*Access/gi,'')
            .replace(/\s*start(er)?\s*pack/gi,'')
            .replace(/[:-]?\s*(Game\s*of\s*the\s*year\s*)/gi,'')
            .replace(/free[\s-]*(2|to)[\s-]*play/ig,'')
            // This removes additional data from games with multiple names, ie. "Resident Evil 5 / Biohazard 5" -> " Resident Evil 5"
            .replace(/\s+\/\s+.+/,'');
        if( (on === orig || doAll) && !excludeGeneric)
        {
            const generic = this.attemptGenericReplacements(on);
            if(generic)
            {
                on = generic;
            }
            on = on.replace(/^The\s*/,'');
        }
        if(on === orig || doAll)
        {
            on = on.replace(/[,\.-\/]/g,' ');
        }
        if(on === orig || doAll)
        {
            // Converts "CamelCaseName" to "Camel Case Name"
            on = on.replace(/([a-z])([A-Z])/g,'$1 $2');
        }
        if(on === "")
        {
            return orig;
        }
        if(on !== orig)
        {
            printv(8,'performNameReplacements: Converted "'+orig+'" to "'+on+'"');
        }
        return on.replace(/\s+/g,' ');
    }

    /*
     * Performs requests from TGD, getting fuzzier until it either finds an
     * entry or fails
     */
    getGameInfoFromTGD(game)
    {
        const ckey = getCacheID(game,'game', { ignoreSteam: true });
        if(cache.existsNotMiss('gameMeta',ckey))
        {
            return cache.get('gameMeta',ckey);
        }
        let data = this.fetchDataFromTGD(game,ckey),
            newName;
        if (!data)
        {
            newName = this.attemptGenericReplacements(game.title,false);
            if(newName !== game.title && newName !== null)
            {
                data = this.fetchDataFromTGD({
                        title: newName,
                        steamID: game.steamID,
                        platform: game.platform
                },ckey);
            }
        }
        if (!data)
        {
            newName = this.performNameReplacements(game.title,true);
            if(newName !== game.title && newName !== null)
            {
                data = this.fetchDataFromTGD({
                        title: newName,
                        steamID: game.steamID,
                        platform: game.platform
                },ckey);
            }
        }
        if (!data)
        {
            newName = this.performNameReplacements(game.title,true,true);
            if(newName !== game.title && newName !== null)
            {
                data = this.fetchDataFromTGD({
                        title: newName,
                        steamID: game.steamID,
                        platform: game.platform
                },ckey);
            }
        }
        if (!data)
        {
            newName = this.performNameReplacements(game.title);
            if(newName !== game.title && newName !== null)
            {
                data = this.fetchDataFromTGD({
                        title: newName,
                        steamID: game.steamID,
                        platform: game.platform
                },ckey);
            }
        }
        if (!data)
        {
            data = this.fetchDataFromTGD({
                    title: game.title,
            },ckey);
        }
        if (!data)
        {
            data = this.fetchDataFromTGD({
                    title: newName,
            },ckey);
        }
        if(data)
        {
            printv(1,'Fetched meta info for '+ game.title );
        }
        else
        {
            printv(1,'Could not fetch metadata for '+ game.title);
        }
        return data;
    }

    /*
     * Download data from TGD, attempting to match it with the provided game
     * data. Entries are then scored, and the best entry (if any) gets
     * returned.
     */
    fetchDataFromTGD(game,ckey)
    {
        let search = this.TGD_search(game.title),
            meta;
        if (!search)
        {
            cache.set(null,'gameMeta',ckey);
            return;
        }
        let platform = this.doPlatformRemap(game.platform);
        if(game.steamID)
        {
            platform = 'PC';
        }
        if(platform !== null && platform !== undefined)
        {
            platform = platform.toLowerCase();
        }
        const name = game.title;
        if(name === null || name === undefined)
        {
            throw('fetchDataFromTGD got NULL title');
        }
        /*
         * Pre-process GameTitle
         */
        for(const replyPreProcess of search)
        {
            replyPreProcess.GameTitle = he.decode(replyPreProcess.GameTitle);
        }
        const filteredName = name.replace(/(™|®|©|\(TM\)|\(R\)|\(C\))/g,'');
        for(const response of search)
        {
            let points = 0;

            if(platform && this.doPlatformRemap(response.Platform).toLowerCase() !== platform)
            {
                response.score = 0;
                continue;
            }

            if(response.GameTitle === game.title)
            {
                points += 20;
            }
            else if(response.GameTitle.toLowerCase() === game.title.toLowerCase())
            {
                points += 10;
            }
            else if(response.GameTitle.toLowerCase().indexOf(filteredName.toLowerCase()) !== -1)
            {
                points += 6;
            }
            else
            {
                let prevLoc = -1;
                const gtLower = response.GameTitle.toLowerCase();
                for(let bit of filteredName.toLowerCase().split(/\s+/))
                {
                    // The substr is to make sure we only check for instaces
                    // later in the string than the previous one (so that the
                    // order of the words is preserved, otherwise we'd get a
                    // lot of strange hits)
                    let idx = gtLower.substr(prevLoc+1).indexOf(bit);
                    if(idx === -1)
                    {
                        bit = bit.replace(/\W/,'');
                        if(bit.length === 0)
                        {
                            continue;
                        }
                        idx = gtLower.substr(prevLoc+1).indexOf(bit);
                    }
                    if(idx !== -1)
                    {
                        prevLoc = idx;
                    }
                    else
                    {
                        prevLoc = -1;
                        break;
                    }
                }
                // We're being a bit picky here in that if we get the wrong platform (or no platform)
                // and the title is much longer than ours, we probably want to skip it
                if (prevLoc !== -1 && !platform && response.GameTitle.length >= (name.length*1.6))
                {
                    // We try a final test here. We perform all relevant replacements on both the
                    // requested name and the response name. Then we see if the response is within
                    // the limts after performing those replacements. If it is then we grant it
                    // a single point. This is to be able to handle responses
                    // that include ie. "limited edition" for short titles.
                    const replacedGT = this.performNameReplacements(response.GameTitle,false,true),
                        replacedName = this.performNameReplacements(name,false,true);
                    if(replacedGT.length < (replacedName.length*1.6) && replacedName.length <= replacedGT.length)
                    {
                        printv(5,'Got a fuzzy hit on "'+response.GameTitle+'" for "'+name+'". The length is over 1.6x that of the requested one (and has no platform match). Granting 1 point because it was within limits after performing replacements.');
                        points = 1;
                    }
                    else
                    {
                        // Still no hit, so we give it a score of 0 points
                        printv(5,'Got a fuzzy hit on "'+response.GameTitle+'" for "'+name+'". Ignoring due to the length being over 1.6x that of the requested one (and no platform match)');
                        points = 0;
                    }
                }
                else if(prevLoc !== -1)
                {
                    // We grant 1.5 points for unreasonably long titles, and 3
                    // points for closer matches
                    if (response.GameTitle.length >= (name.length*1.6))
                    {
                        points += 1.5;
                    }
                    else
                    {
                        points += 3;
                    }
                }
            }
            // If the name doesn't match nothing else matters
            if(points === 0)
            {
                response.score = points;
                continue;
            }
            if(response.ReleaseDate && response.ReleaseDate.length)
            {
                const year = response.ReleaseDate.split('/')[2];
                if (game.year && year === game.year)
                {
                    points += 3;
                }
            }

            response.score = points;
        }
        search = search.sort((a,b) =>
        {
                return b.score - a.score;
        });
        while(search.length > 0)
        {
            const best = search.shift();
            if(best.score > 0)
            {
                meta = this.TGD_infoByID(best.id);
                if(meta !== undefined)
                {
                    cache.set(meta,'gameMeta',ckey);
                    return meta;
                }
            }
        }
        cache.set(null,'gameMeta',ckey);
        return;
    }

    /*
     * Retrieves a complete entry from TGD, by its TGD id number
     */
    TGD_infoByID(id)
    {
        const result = this.TGD_request('GetGame',{ id});
        if(result && result.Data && result.Data.Game)
        {
            result.Data.Game.baseImgUrl = result.Data.baseImgUrl;
            return result.Data.Game;
        }
        return;
    }

    /*
     * Performs a TGD search
     */
    TGD_search(game)
    {
        const result = this.TGD_request('GetGamesList',{ name: game });
        if(result && result.Data && result.Data.Game)
        {
            return this.mustBeArray(result.Data.Game);
        }
        return;
    }

    /*
     * Constructs a request for GD
     */
    TGD_request(call,parameters)
    {
        let rqURL = 'http://thegamesdb.net/api/'+call+'.php?';
        const finalParams = [];
        for(const key in parameters)
        {
            finalParams.push(encodeURIComponent(key)+'='+encodeURIComponent(parameters[key]));
        }
        rqURL += finalParams.join('&');
        return this.XMLtoJSONRequest(rqURL);
    }
}

/*
 * This is the API that generates the collection with metadata and posters for
 * a book collection
 */
class bookCollection extends collectionType
{
    // Parent constructor will call initialize for us after it has done the construction
    initialize ()
    {
        Object.assign(this._meta,
        {
            genres: []
        });
        this._includedEntryData = {
            'published':true,
            'pages':true,
            'openliblink':true,
            'isbn':true,
            'author':true,
            'sortableAuthor':true,
            'language':true,
            'publisher':true
        };
        if(this._entry.defaultSort === undefined)
        {
            this._entry.defaultSort = 'sortableAuthor';
        }
    }

    addMetadataTo (data)
    {
        if (!data.isbn)
        {
            printv(3,'Skipping downloading metadata for entry due to missing ISBN: '+JSON.stringify(data));
            return;
        }
        const remote = this.getMetadataFor(data);
        if(remote)
        {
            const fieldRemap = {
                'description':'plot',
                'publishedDate':'published',
                'pageCount':'pages',
                'publisher':'publisher'
            };
            for (const source in remote)
            {
                let targetName = fieldRemap[source];
                if(targetName === undefined)
                {
                    targetName = source;
                }
                if (!data[targetName] && remote[source])
                {
                    data[targetName] = remote[source];
                }
            }
            if(remote.infoLink)
            {
                if(/^https?:\/\/(www\.)?openlibrary.org/.test(remote.infoLink))
                {
                    data.openliblink = remote.infoLink;
                }
            }
            if (!data.author && remote.authors)
            {
                data.author = this.mustBeString(remote.authors);
            }
            if(remote.imageLinks && remote.imageLinks.thumbnail !== undefined && this.isValidCoverURL(remote.imageLinks.thumbnail))
            {
                data.metadataPoster = remote.imageLinks.thumbnail;
            }
        }
        if(data.genre)
        {
            this._meta.genres = this._meta.genres.concat(data.genre.split(/,\s*/));
        }
        if(data.author)
        {
            const possibleAuthors = data.author.split(/\s+/);
            let prevAuthorValue;
            let sortableAuthor = '';
            for(const entry of possibleAuthors)
            {
                if(entry.substr(0,1) === entry.substr(0,1).toLowerCase())
                {
                    sortableAuthor += prevAuthorValue;
                    continue;
                }
                else if(/\,$/.test(prevAuthorValue))
                {
                    sortableAuthor += prevAuthorValue;
                }
                prevAuthorValue = entry;
            }
            if(prevAuthorValue)
            {
                sortableAuthor += prevAuthorValue;
            }
            data.sortableAuthor = sortableAuthor;
        }
    }

    getMetadataFor(data)
    {
        const isbnNumber = data.isbn.replace(/\D/g,'');
        const ckey = getCacheID(isbnNumber,'book');
        let remote;
        if(cache.existsNotMiss('bookMeta',ckey))
        {
            remote = cache.get('bookMeta',ckey);
        }
        else
        {
            printv(4,'Performing metadata request for ISBN '+isbnNumber);
            try
            {
                remote = wait.for(isbn.resolve,isbnNumber);
            }
            catch (e)
            {
                // Ignore errors, remote will be undefined which is fine
            }
            cache.set(remote,'bookMeta',ckey);
        }
        return remote;
    }

    addPosterToItem (data)
    {
        const posterID = data.isbn;
        posterID.replace(/-/g,'');
        let file;
        if(data.poster)
        {
            file = this.downloadPoster(data.poster,data);
        }
        if(file === undefined)
        {
            file = this.downloadPoster('http://covers.openlibrary.org/b/isbn/'+posterID+'-L.jpg?default=false',data);
        }
        if(file === undefined && data.metadataPoster)
        {
            file = this.downloadPoster(data.metadataPoster,data);
        }
        if(file)
        {
            data.poster = file;
        }
        else
        {
            data.poster = undefined;
        }
    }
}

/*
 * Shared helper functions used by the rest of rotcelloc
 */
const helper = {
    /*
     * Resolve the path to a file relative to our source directory
     */
    resolvePath(file)
    {
        return __dirname+'/'+file;
    },
    /*
     * Resolve a path relative to our output directory
     */
    resolveOutPath(file)
    {
        if(outputDir === null)
        {
            if(commander.config)
            {
                outputDir = path.dirname(commander.config);
            }
            else if(fs.existsSync(process.cwd()+'/rotcelloc.config.cson'))
            {
                outputDir = process.cwd();
            }
            else
            {
                outputDir = __dirname;
            }
            outputDir = fs.realpathSync(outputDir);
            printv(5,'Resolved output directory to '+outputDir);
        }
        return outputDir+'/'+file;
    },
    /*
     * Return the config datastructure
     */
    getConfig()
    {
        if(runtimeCache.config)
        {
            return runtimeCache.config;
        }
        let configCSON = helper.resolveOutPath('rotcelloc.config.cson'),
            config;
        if(commander.config)
        {
            configCSON = commander.config;
            if (!fs.existsSync(configCSON))
            {
                console.log(configCSON+': does not exist');
                process.exit(1);
            }
        }
        else if (!fs.existsSync(configCSON))
        {
            printv(4,helper.resolveOutPath('rotcelloc.config.cson')+': does not exist');
            console.log('Error: you must configure rotcelloc first (or provide a --config). Aborting.');
            console.log('See the user guide in README.md');
            process.exit(1);
        }
        try
        {
            config  = CSON.parse(fs.readFileSync(configCSON));
        }
        catch(e)
        {
            throw('Failed to parse rotcelloc.config.cson: '+e.stack);
        }
        // Perform maxMoviesPerRenderedPage & maxMoviesPerRenderedPageMobile remapping
        if(config.maxMoviesPerRenderedPage && !config.maxEntriesPerRenderedPage)
        {
            config.maxEntriesPerRenderedPage = config.maxMoviesPerRenderedPage;
            delete config.maxMoviesPerRenderedPage;
        }
        if(config.maxMoviesPerRenderedPageMobile && !config.maxEntriesPerRenderedPageMobile)
        {
            config.maxEntriesPerRenderedPageMobile = config.maxMoviesPerRenderedPageMobile;
            delete config.maxMoviesPerRenderedPageMobile;
        }
        runtimeCache.config = config;
        return config;
    },
    /*
     * Check if a command is available in PATH
     */
    inPath(command)
    {
        for(const directory of process.env.PATH.split(':'))
        {
            // This should also check if it is executable
            if(fs.existsSync(directory+'/'+command))
            {
                return true;
            }
        }
        return false;
    },
    /*
     * A simple "sleep" function that takes a sleep time in seconds and then
     * uses wait.for and a setTimeout to do the sleeping
     */
    sleep(sleepTime)
    {
        sleepTime = sleepTime*1000;
        wait.for((cb) =>
        {
            // eslint-disable-next-line brace-style
                setTimeout(() => { cb(); }, sleepTime);
        });
    },

    /*
     * Retrieve a checksum
     */
    checksum(targetStr)
    {
		const shasum = crypto.createHash('sha1');
        shasum.update(targetStr);
        return shasum.digest('hex');
    },
};

/*
 * The core application, prepares the build environment, calls build functions,
 * prepares images and writhes the CCS
 */
const core = {
    /*
     * Writes a out the final dataset and HTML fiels for a collection group
     */
    writeOutResult(groupMeta,groupData,groupNo,name,config,results)
    {
        const dataset = {
            i18n: i18n.strings,
            config,
            data: groupData,
            meta: groupMeta,
            // dVer is the dataset version, it is validated in the front-end JS
            // to make sure that it doesn't try to render an unsupported dataset
            // version. Should only be bumped on a non-backwards compatible change.
            // The test in rotcelloc.js also needs to be modified in that case.
            dVer: 0,
            version: packageJSON.version
        };

        const strDataset = JSON.stringify(dataset);
        const checksum = helper.checksum(strDataset);

        webappGen.writePageFor(name,groupNo,results,checksum);

        fs.writeFileSync(helper.resolveOutPath('out/'+name.toLowerCase().replace(/\s+/g,'_')+'.dataset.json'),strDataset);
    },
    /*
     * Loads the config, the i18n data, then hands control over to the various
     * APIs to let them build the actual databases.
     */
    constructDatabase()
    {
        const config  = helper.getConfig();

        cache = new rotcellocCache();
        if(config.language && fs.existsSync(helper.resolvePath('i18n/'+config.language+'.po')))
        {
            i18n.strings = po2json.parseFileSync(helper.resolvePath('i18n/'+config.language+'.po'), {
                    format: 'mf',
                    'fallback-to-msgid':true
            });
        }
        let groupNo = 0;
        const results = [];
        for (const name in config.collections)
        {
            groupNo++;
            printv(2,' Constructing group "'+name+'"');
            const groupConf = config.collections[name];
            let result;
            if(groupConf.type === 'series' || groupConf.type === 'movies')
            {
                const handler = new movieCollection(groupConf,name,groupNo);
                result = handler.generateDatastructure();
            }
            else if(groupConf.type === 'games')
            {
                const handler = new gameCollection(groupConf,name,groupNo);
                result = handler.generateDatastructure();
            }
            else if(groupConf.type === 'books')
            {
                const handler = new bookCollection(groupConf,name,groupNo);
                result = handler.generateDatastructure();
            }
            else
            {
                throw('Unhandled group type: '+groupConf.type+' for '+groupConf.name);
            }
            results.push({
                    result,
                    groupNo,
                    name,
                    config,
            });
        }
        for(const entry of results)
        {
            core.writeOutResult(entry.result.meta, entry.result.data, entry.groupNo, entry.name, entry.config, results);
        }
        cache.autoExpireOutdatedEntries();
        cache.flushIfNeeded();
    },
    /*
     * Verifies command-line dependencies
     */
    verifyDeps()
    {
        let errOut = false;
        if (!helper.inPath('sass'))
        {
            console.log('Error: "sass" is missing, it is required to compile the CSS\nPlease install sass (either through the package manager or with "gem install sass")');
            errOut = true;
        }
        if (!helper.inPath('rsync'))
        {
            console.log('Error: "rsync" is missing, it is required to copy files\nPlease install rsync');
            errOut = true;
        }
        if(errOut)
        {
            process.exit(1);
        }
    },
    /*
     * Wrapper that performs the actual building
     */
    build()
    {
        core.verifyDeps();
        // Load the config. Also verifies that it actually exists and outputs
        // an error if it doesn't.
        const config = helper.getConfig();
        printv(1,'rotcelloc version '+packageJSON.version+' running');

        if (commander.deploy && (config.deployTo === null || config.deployTo === undefined))
        {
            console.log('ERROR: deployTo is not set in the config. Can not deploy.');
            process.exit(1);
        }

        if(fs.existsSync(helper.resolveOutPath('out')))
        {
            printv(1,'Cleaning up old files...');
            // Keep the old tarball if it exists
            if(fs.existsSync(helper.resolveOutPath('out/rotcelloc.tar.bz2')))
            {
                if(fs.existsSync(helper.resolveOutPath('rotcelloc.tar.bz2~')))
                {
                    fs.unlinkSync(helper.resolveOutPath('rotcelloc.tar.bz2~'));
                }
                fs.renameSync(helper.resolveOutPath('out/rotcelloc.tar.bz2'),helper.resolveOutPath('.rotcelloc.tar.bz2~'));
            }
            const oldFiles = wait.for(glob,helper.resolveOutPath('out/*'));
            for (const oldFile of oldFiles)
            {
                if(fs.statSync(oldFile).isFile())
                {
                    fs.unlinkSync(oldFile);
                }
            }
        }
        if (!fs.existsSync(helper.resolveOutPath('out')))
        {
            fs.mkdirSync(helper.resolveOutPath('out'));
        }
        if (!fs.existsSync(helper.resolveOutPath('.rotcellocdata')))
        {
            fs.mkdirSync(helper.resolveOutPath('.rotcellocdata'));
        }
        if (!fs.existsSync(helper.resolveOutPath('.rotcellocdata/images')))
        {
            fs.mkdirSync(helper.resolveOutPath('.rotcellocdata/images'));
        }
        if (!fs.existsSync(helper.resolveOutPath('.rotcellocdata/images/orig')))
        {
            fs.mkdirSync(helper.resolveOutPath('.rotcellocdata/images/orig'));
        }
        if(fs.existsSync(helper.resolveOutPath('.rotcelloc.tar.bz2~')))
        {
            fs.renameSync(helper.resolveOutPath('.rotcelloc.tar.bz2~'),helper.resolveOutPath('out/rotcelloc.tar.bz2'));
        }
        if(fs.existsSync(helper.resolveOutPath('.images')))
        {
            console.log('Note: you appear to have an old rotcelloc 0.1 .images directory\n      This can be safely deleted.');
        }
        if(fs.existsSync(helper.resolveOutPath('.cache.json')) && !fs.existsSync(helper.resolveOutPath('.rotcellocdata/cache.json')))
        {
            printv(2,'Moved .cache.json to .rotcellocdata/cache.json');
            fs.renameSync('.cache.json','.rotcellocdata/cache.json');
        }

        printv(1,'Building database...');
        core.constructDatabase();
        this.resizeImages();
        printv(1,'Preparing webapp...');
        webappGen.finalize();
        if(commander.deploy)
        {
            printv(1,'Deploying with rsync...');
            child_process.execFileSync('rsync', [ '--checksum', '-avh', '--progress', '--partial', '--inplace','--exclude=images/orig', '--copy-links', '--delete-excluded', '--delete','out/',config.deployTo ], { stdio: 'inherit' });
        }
    },
    resizeImages ()
    {
        printv(1,'Preparing images...');
        const files = wait.for(glob,helper.resolveOutPath('.rotcellocdata/images/orig/*'));
        for(const file of files)
        {
            if(! fs.existsSync(helper.resolveOutPath('.rotcellocdata/images/'+path.basename(file))))
            {
                printv(3,'Creating resized version of '+path.basename(file));
                const targetFile = helper.resolveOutPath('.rotcellocdata/images/'+path.basename(file));
                const imgObj = gm(file);
                const width = wait.forMethod(imgObj,'size');
                if(width !== undefined && width.width > 270)
                {
                    printv(4,'Skipped resizing '+path.basename(file)+' - it is smaller than our target');
                    fs.symlinkSync(file,targetFile);
                    continue;
                }
                imgObj.resize('270');
                wait.forMethod(imgObj,'write',targetFile);
            }
        }
    },
    /*
     * Write the "complete and corresponding" source code for the installed
     * version of rotcelloc to a file
     */
    writeCCS()
    {
        const selfFiles = [
            { 'path': 'README.md' },
            { 'path': 'Makefile' },
            { 'path': 'LICENSE' },
            { 'path': 'NEWS' },
            { 'path': 'package.json' },
            { 'path': 'yarn.lock' },
            { 'path': 'rotcelloc.config.cson.tpl' },
            { 'path': 'src/rotcelloc.js' },
            { 'path': 'src/template.ejs' },
            { 'path': 'src/style.css.scss' },
            { 'path': 'tools/gogExporterBookmarklet.js' },
            { 'path': 'tools/imdbConvert' }
        ];

        for (const globbed of [ 'i18n/*.po*','examples/*.csv','examples/*cson'])
        {
            const baseDir = path.dirname(globbed);
            for(const subfile of wait.for(glob,helper.resolvePath(globbed)))
            {
                selfFiles.push({
                    path: baseDir+'/'+path.basename(subfile),
                    qualified: subfile
                });
            }
        }
        selfFiles.unshift({ 'path': 'rotcelloc', 'qualified':__filename });
        if(fs.existsSync(helper.resolveOutPath('out/rotcelloc.tar.bz2')))
        {
            // There's already a tarball. We do a stupid comparison between the
            // tarball and ourselves, if we're newer than the tarball, we
            // generate a new one anyway, otherwise we keep the existing one.
            const tarball = fs.statSync(helper.resolveOutPath('out/rotcelloc.tar.bz2'));
            let tarballUpToDate = true;
            for(const comparison of selfFiles)
            {
                const compare = fs.statSync(helper.resolvePath(comparison.path));
                if(compare.mtime.getTime() > tarball.mtime.getTime())
                {
                    tarballUpToDate = false;
                    break;
                }
            }
            if(tarballUpToDate)
            {
                printv(4,'Keeping existing source code archive');
                return;
            }
            else
            {
                printv(4,'A source code archive already existed, but rotcelloc is newer than it is. Will regenerate the archive.');
                fs.unlinkSync(helper.resolveOutPath('out/rotcelloc.tar.bz2'));
            }
        }
        printv(3,'Generating source code archive...');

        const currCWD = process.cwd();
        if (!fs.existsSync(helper.resolveOutPath('out/rotcelloc/')))
        {
            fs.mkdirSync(helper.resolveOutPath('out/rotcelloc'));
        }
        process.chdir(helper.resolveOutPath('out'));

        const directories = [];
        for(const file of selfFiles)
        {
            if (!file.qualified)
            {
                file.qualified = helper.resolvePath(file.path);
            }
            let dirTree = path.dirname(file.path);
            if(dirTree === file || dirTree === '.')
            {
                dirTree = '';
            }
            if(dirTree)
            {
                if (!fs.existsSync(helper.resolveOutPath('out/rotcelloc/'+dirTree)))
                {
                    fs.mkdirSync(helper.resolveOutPath('out/rotcelloc/'+dirTree));
                }
                directories.unshift(dirTree);
            }
            child_process.execFileSync('cp',[ file.qualified,helper.resolveOutPath('out/rotcelloc/'+file.path) ]);
        }
        child_process.execFileSync('tar',['-jcf','./rotcelloc.tar.bz2','./rotcelloc' ]);
        directories.sort((a, b) =>
        {
                return b.length - a.length;
        });
        for(const fileI of selfFiles)
        {
            fs.unlinkSync('./rotcelloc/'+fileI.path);
        }
        for(const dirI of directories)
        {
            if(fs.existsSync('./rotcelloc/'+dirI))
            {
                fs.rmdirSync('./rotcelloc/'+dirI);
            }
        }
        printv(3,'Wrote source code archive to rotcelloc.tar.bz2');
        fs.rmdirSync('./rotcelloc');
        process.chdir(currCWD);
    }
};

/*
 * Web application generator component
 */
const webappGen = {
    versions: {
        jQueryVersion: '3.2.0',
        bootstrapVersion: '3.3.7',
        lodashVersion: '3.10.0'
    },
    subresourceIntegrity: {
        bootstrap: 'sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u',
        bootstrapTheme: 'sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp',
        bootstrapJS: 'sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa',
        lodashJS: 'sha384-srT/6JQ6ycJ3D5onKplmziF9E34jqWvcVjluRlqbqqin62ky70yGR8l6NQvjbFRS',
        jQuery: 'sha384-o9KO9jVK1Q4ybtHgJCCHfgQrTRNlkT6SL3j/qMuBMlDw3MmFrgrOHCOaIMJWGgK5',
    },
    createFilename(name,groupNo)
    {
        let filename;
        if(groupNo === 1)
        {
            filename = 'index.html';
        }
        else
        {
            filename = name.toLowerCase().replace(/\s+/g,'_');
            filename += '.html';
        }
        return filename;
    },
    writePageFor(name,groupNo,results,checksum)
    {
        const filename = webappGen.createFilename(name,groupNo);
        let template = fs.readFileSync(helper.resolvePath('src/template.ejs'));
        template = template.toString();
        const footer = util.format(i18n.translate('Generated by <a href="%s">%s</a> version %s. <a href="%s">Download source code.</a> Software licensed under the <a target="_blank" href="%s">%s</a>. Content is copyrighted by their respective owners.'),'http://random.zerodogg.org/','rotcelloc',packageJSON.version,'rotcelloc.tar.bz2','https://gnu.org/licenses/agpl-3.0-standalone.html','GNU AGPLv3');
        const menu = [];
        for(const entry of results)
        {
            const fname = webappGen.createFilename(entry.name,entry.groupNo);
            menu.push({
                    url: fname,
                    state: entry.groupNo === groupNo ? 'current' : '',
                    title: entry.name
            });
        }
        const content = ejs.render(template, {
                document: {
                    title: name,
                },
                versions: webappGen.versions,
                subresourceIntegrity: webappGen.subresourceIntegrity,
                config: helper.getConfig(),
                footer,
                menu,
                content: '<div class="searchForm" id="searchForm"></div><div id="collResultTarget" data-checksum="'+checksum+'" data-pagetype="'+name+'">'+i18n.translate('Loading collection...')+'</div>',
            },
            {
                rmWhitespace: true
            }
        );
        fs.writeFileSync(helper.resolveOutPath('out/'+filename),content);
    },
    finalize()
    {

        if (!fs.existsSync(helper.resolvePath('src/deps/bootstrap-variables.scss')))
        {
            printv(1,'Fetching dependency: bootstrap-variables.scss');
            const bootstrapVars = wait.forMethod(httpreq,'get', 'https://raw.githubusercontent.com/twbs/bootstrap-sass/v'+webappGen.versions.bootstrapVersion+'/assets/stylesheets/bootstrap/_variables.scss');
            fs.writeFileSync(helper.resolvePath('src/deps/bootstrap-variables.scss'), bootstrapVars.body);
            printv(1,'Continuing...');
        }

        printv(3,'Copying images...');
        // Copies the downloaded posters
        child_process.execFileSync('rsync', [ '-a','--copy-links','--delete', '--exclude=orig/', helper.resolveOutPath('.rotcellocdata/images/'), helper.resolveOutPath('./out/images/') ]);
        // Copy .gitignore if neded
        if (!fs.existsSync(helper.resolveOutPath('.gitignore')))
        {
            printv(4,'Copied .gitignore to '+helper.resolveOutPath('.gitignore'));
            child_process.execFileSync('rsync', [ '-a',helper.resolvePath('.gitignore'), helper.resolveOutPath('.gitignore') ]);
        }
        printv(3,'Compiling JS and CSS...');
        let babelified, uglified;
        try
        {
            babelified = babel.transform(fs.readFileSync(helper.resolvePath('src/rotcelloc.js')),
                {
                    'babelrc':false,
                    sourceMaps: true,
                    sourceFileName: 'rotcelloc.js',
                    sourceMapTarget: 'rotcelloc.js',
                    'presets':['babel-preset-es2015'].map(require.resolve)
                }
            );
        }
        catch(e)
        {
            throw('Failed to compile rotcelloc.js with babel: '+e.message);
        }
        try
        {
            uglified = UglifyJS.minify({ 'rotcelloc.js':babelified.code},{
                    warnings: true,
                    inSourceMap: babelified.map,
                    fromString: true,
                    outSourceMap: 'rotcelloc.js.map',
                });
        }
        catch(e)
        {
            throw('Failed to uglify rotcelloc.js: '+e.message);
        }
        fs.writeFileSync(helper.resolveOutPath('out/rotcelloc.js'),uglified.code);
        fs.writeFileSync(helper.resolveOutPath('out/rotcelloc.js.map'),uglified.map);
        process.env.RUBYOPT = '-W0';
        child_process.execFileSync('sass',[ '--scss','--quiet',helper.resolvePath('src/style.css.scss'),helper.resolveOutPath('out/style.css') ]);

        try
        {
            core.writeCCS();
        }
        catch(e)
        {
            printv(1,'Warning: failed to write source code archive');
            printv(4,'Error when writing CCS: '+e.message);
        }
    }
};

/*
 * Generates and returns a cache ID string that will be unique to this entry
 * and can be used to store and retrieve data in the persistent cache
 */
function getCacheID (entry,type,opts)
{
    let ckey = '';
    if(typeof(entry) === 'object')
    {
        if(type === undefined)
        {
            type = entry.type;
        }
        if(entry.origTitle)
        {
            ckey = entry.origTitle;
        }
        else if(entry.title)
        {
            ckey = entry.title;
        }
        else
        {
            ckey = entry.name;
        }
        if(entry.altTitle)
        {
            ckey += '//'+entry.altTitle;
        }
        ckey += '//'+entry.year;
    }
    else
    {
        if(type === undefined)
        {
            type = 'unknown';
        }
        ckey = entry;
    }
    if(type === 'series')
    {
        ckey += 'tvserie';
    }
    else if(type === 'game')
    {
        ckey += '//game';
        if(entry.platform)
        {
            ckey += '//'+entry.platform;
        }
        if(entry.steamID && (!opts || !opts.ignoreSteam))
        {
            ckey += '//steam-'+entry.steamID;
        }
    }
    else if(type !== undefined)
    {
        ckey += '//'+type;
    }
    return ckey;
}
/*
 * Prints a message if the verbosity level is high enough
 */
function printv(reqVerb,message)
{
    if(commander.verbose >= reqVerb)
    {
        if (reqVerb > 1 && !/^\s+/.test(message))
        {
            let spaces = '';
            for(let n = 1; reqVerb >= n; n++)
            {
                spaces += ' ';
            }
            message = spaces+message;
        }
        console.log(message);
    }
}
/*
 * Main entry points. Parses and performs actions depending on the command-line
 * parameters
 */
function main()
{
    // Handle SIGINT
    process.on('SIGINT', () =>
    {
            console.log('Received SIGINT, flushing cache and exiting.');
            if(cache !== undefined && cache.flushIfNeeded)
            {
                cache.flushIfNeeded();
            }
            process.exit(9);
    });
    try
    {
        packageJSON = JSON.parse(fs.readFileSync(helper.resolvePath('package.json')));
    }
    catch(e)
    {
        packageJSON = { 'version':'UNKNOWN' };
    }

    commander
    .version(packageJSON.version)
    .option('-q, --quiet','be quiet (overrides any --verbose arguments)')
    // eslint-disable-next-line brace-style
    .option('-v, --verbose','increase verbosity', (v,total) => { return total + 1;},1)
    .option('--deploy','build the collection and webapp and then deploy as defined in the config')
    .option('--retry-miss','retry fetching data or covers where those have failed previously')
    .option('--include-debug','include debugging metadata')
    .option('--expire-matching [match]','expire all cached data where the key case insensitively matches [match] and exit')
    .option('--force-steam-update','force an update of the lists of Steam games')
    .option('--config [file]','read [file] instead of ./rotcelloc.config.json')
    .option('--lazy','only use cached data')
    .parse(process.argv);

    if(commander.quiet)
    {
        commander.verbose = 0;
    }
    else if (!commander.verbose)
    {
        commander.verbose = 1;
    }

    if (!fs.existsSync(helper.resolvePath('src/rotcelloc.js')))
    {
        console.log('Run me from the right directory (root of the tree)');
        process.exit(1);
    }

    /* Handle exclusive options */
    if(commander.expireMatching)
    {
        cache = new rotcellocCache();
        cache.cacheExpiry(commander.expireMatching);
        process.exit(0);
    }

    core.build();
}

/*
 * Executes "main" inside a fiber instance, which is then used by waitfor to
 * make functions that are normally async execute synchronously.
 */
wait.launchFiber(main);
