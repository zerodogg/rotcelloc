#!/usr/bin/env node
/*
 * vim: set ft=javascript :
 *
 * rotcelloc command-line management app
 *
 * Part of rotcelloc - the hacker's movie, tv-series and game collection
 * manager
 *
 * Copyright (C) Eskild Hustvedt 2015, 2016, 2017
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
// jshint esnext: true, eqnull: true

"use strict";

// Load modules
try
{
    var
        // For parsing the collection files
        parse         = require('csv').parse,
        // Needed to perform filesystem operations
        fs            = require('fs'),
        // Used to retrieve movie art
        movieArt      = require('movie-art'),
        // Used to make async stuff be synchronous for command-line use
        wait          = require('wait.for'),
        // Perform HTTP requests
        httpreq       = require('httpreq'),
        // Used to clean up paths
        path          = require('path'),
        // Various helpers
        _             = require('lodash'),
        // Perform glob operations to easily perform actions on covers
        glob          = require('glob'),
        // Command-line parameter parsing
        commander     = require('commander'),
        // Used to call system commands
        child_process = require('child_process'),
        // Used for printf-like formatting
        util          = require('util'),
        // Scrapes Steam to retreive the list of games a Steam user owns
        steam         = require('happy-steam-scraper'),
        // Used to decode HTML entities
        he            = require('he'),
        // Used to parse APIs that return XML instead of JSON
        xml2json      = require('xml2json'),
        // Used to compile our template
        ejs           = require('ejs'),
        // Used to minify JS
        UglifyJS      = require("uglify-js"),
        // Converts PO files to a JSON structure
        po2json       = require('po2json'),
        // Loads CSON files
        CSON          = require('cson'),
        // Used for hasing
        crypto        = require('crypto');
}
    catch(e)
{
    console.log('You are missing some rotcelloc dependencies: '+e.message);
    console.log('Please install the dependencies with "npm install" and try again');
    process.exit(1);
}

var
    // Global cache object
    cache = null,
    // Used for caching during a single run, ie. for http-requests
    runtimeCache = {},
    // Stores a parsed version of package.json, basically just used
    // to lazily get our version number without having to duplicate it
    // in multiple files.
    packageJSON = null,
    // Output directory
    outputDir = null,
    // Global i18n handling (including translation function)
    i18n = {
        strings: {},
        translate: function (s)
        {
            return this.strings[s] ? this.strings[s] : s;
        }
};

/*
 * Cache class
 */
class rotcellocCache
{
    constructor ()
    {
        this._persistCache = {};
        // Used to keep track of the number of times the cache data has
        // been changed since the last time we wrote it to disk.
        this._writesSinceFlush = 0;

        // Used for *all* access bumps during this objects lifetime
        this._objectLifetimeID = Math.floor(Date.now() / 1000);
        // Used to check how long it is since we last did a write
        // to avoid writing too often
        this._lastWritten = 0;

        // Load and initialize _persistCache
        if(fs.existsSync(helper.resolveOutPath('.cache.json')))
        {
            printv(3,'Loading cache from .cache.json');
            this._persistCache = JSON.parse(fs.readFileSync(helper.resolveOutPath('.cache.json')));
        }
        if (!this._persistCache.URLs)
        {
            this._persistCache = { URLs: this._persistCache };
        }
        if (!this._persistCache.fileMap || commander.expireCovers)
        {
            this._persistCache.fileMap = {};
        }
        if (!this._persistCache.meta || commander.expireMeta)
        {
            this._persistCache.meta = {};
        }
        if (!this._persistCache.gameMeta || commander.expireMeta)
        {
            this._persistCache.gameMeta = {};
        }
        if (!this._persistCache.steamMeta || commander.expireMeta)
        {
            this._persistCache.steamMeta = {};
        }
        if (!this._persistCache.arbitrary || commander.expireMeta)
        {
            this._persistCache.arbitrary = {};
        }
        if (!this._persistCache._meta)
        {
            this._persistCache._meta = {};
        }
    }

    get (cacheType,ckey)
    {
        if(this._persistCache[cacheType] === undefined)
        {
            throw('Attempt to get() from unknown cache type: '+cacheType);
        }
        this.bumpAccessTime(cacheType,ckey);
        return this._persistCache[cacheType][ckey];
    }

    set (content,cacheType,ckey)
    {
        if(this._persistCache[cacheType] === undefined)
        {
            throw('Attempt to set() to unknown cache type: '+cacheType);
        }
        this._persistCache[cacheType][ckey] = _.cloneDeep(content);
        this.bumpAccessTime(cacheType,ckey);
        this._writesSinceFlush++;
        this.autoWrite();
    }

    bumpAccessTime (cacheType,ckey)
    {
        this._persistCache._meta[ cacheType + '___' + ckey ] = this._objectLifetimeID;
    }

    getAutoKey(cacheType,entry,type,opts)
    {
        let ckey = getCacheID(entry,type,opts);
        return this.get(cacheType,ckey);
    }

    setAutoKey(content,cacheType,entry,type,opts)
    {
        let ckey = getCacheID(entry,type,opts);
        return this.set(content,cacheType,ckey);
    }

    unset(cacheType,ckey)
    {
        delete this._persistCache[cacheType][ckey];
        this.autoWrite();
    }

    unsetAutoKey(cacheType,entry,type,opts)
    {
        let ckey = getCacheID(entry,type,opts);
        return this.unset(cacheType,ckey);
    }

    write()
    {
        this._writesSinceFlush = 0;
        this._lastWritten = Math.floor(Date.now() / 1000);
        this._persistCache.lastVersion = packageJSON.version;
        this._persistCache.formatVersion = 0;
        this._persistCache.lastObjID = this._objectLifetimeID;
        printv(5,'Writing cache to .cache.json');
        fs.writeFileSync('.cache.json.out',JSON.stringify(this._persistCache));
        fs.renameSync('.cache.json.out','.cache.json');
    }

    autoWrite()
    {
        if(this._writesSinceFlush > 50)
        {
            let now = Math.floor(Date.now() / 1000);
            if(now-this._lastWritten >= 4)
            {
                this.write();
            }
        }
    }

    flushIfNeeded()
    {
        if(this._writesSinceFlush > 0)
        {
            this.write();
        }
    }

    cacheExpiry (byvalue,onlyMiss)
    {
        byvalue = byvalue.toLowerCase();
        for (let type of [ 'meta', 'URLs', 'gameMeta','arbitrary','steamMeta' ])
        {
            let result = this._persistCache[type];
            for (let entry in result)
            {
                if(entry.toLowerCase().indexOf(byvalue) != -1 || byvalue === '')
                {
                    if(onlyMiss && result[entry] != 'MISS')
                    {
                        continue;
                    }
                    console.log(type+': removed "'+entry+'"');
                    delete result[entry];
                }
            }
            if(type == 'steamMeta')
            {
                for(let entry in result)
                {
                    let data = result[entry];
                    if(data.name && data.name.toLowerCase().indexof(byvalue) != -1)
                    {
                        if(onlyMiss && result[entry] != 'MISS')
                        {
                            continue;
                        }
                        console.log(type+': removed "'+entry+'"');
                        delete result[entry];
                    }
                }
            }
        }
        this.write();
    }

    autoExpireOutdatedEntries ()
    {
        let now = Math.floor(Date.now() / 1000);
        for (let type of [ 'meta', 'URLs', 'gameMeta','arbitrary','steamMeta' ])
        {
            let result = this._persistCache[type];
            for (let entry in result)
            {
                let accessKey = type + '___' + entry;
                // 100800 seconds = four weeks
                if (this._persistCache._meta[accessKey] === undefined || (now-this._persistCache._meta[accessKey]) >= 100800)
                {
                    printv(7,'Removed expired cache entry of type '+type+' for '+entry);
                    delete result[entry];
                }
            }
        }
        this._writesSinceFlush++;
    }
}

/*
 * Base class for all collection types. Implements generic versions of
 * most methods which can then be overridden
 */
class collectionType
{
    constructor(entry, name, groupNumber)
    {
        this._entry = entry;
        this._name = name;
        this._groupNo = groupNumber;
        this._ID = 0;
        this._curBsource = null;
        this._meta = {
            sourceToNameMap: {},
            type: this._entry.type
        };
        if(this.initialize)
        {
            this.initialize();
        }
    }

    // Load data from a source
    loadData(source)
    {
        // This basic version assumes CSV data. Subclasses can override
        // loadData() with its own logic.
        return this.loadCSVData(source);
    }

    // Load data from a CSV
    loadCSVData(entry)
    {
        printv(3,'Interpreting file "'+entry.file+'"');
        this._meta.sourceToNameMap[path.basename(entry.file)] = entry.name;
        this._curBsource = path.basename( entry.file );

        let input  = fs.readFileSync(helper.resolveOutPath(entry.file),{ encoding: 'utf-8'} );
        let CSV = wait.for(parse,input, {comment: '#', delimiter: ';', trim: true, columns: true, relax_column_count: true, skip_empty_lines: false});
        let baseF = path.basename(entry.file);
        let config = helper.getConfig();
        let blameData;
        if(config.enableAutoAdded !== false)
        {
            blameData = this.loadGitBlame(entry.file);
        }
        for(let i = 0; i < CSV.length; i++)
        {
            let entry = CSV[i];
            helper.remapCSVFields(entry);
            helper.handleGenericFields(entry);
            if (blameData != null && entry.added === 0)
            {
                let blameLine = i-1;
                let blamed = blameData[blameLine];
                if(blamed && blamed['committer-time'])
                {
                    entry.added = blamed['committer-time'];
                }
            }
        }
        printv(5,'Loaded CSV from '+entry.file);
        return CSV;
    }

    // Load git blame data for a file
    loadGitBlame(path)
    {
        let gitBlameOutput;
        try
        {
            gitBlameOutput = child_process.execFileSync('git',['blame','--line-porcelain','-w','--minimal','-C',path],{ stdio: [ 'ignore','pipe','ignore' ] });
        }
        catch(e)
        {
            printv(4,'Error during execFileSync of git blame: '+e.message);
            return [];
        }
        gitBlameOutput = gitBlameOutput.toString();
        gitBlameOutput = gitBlameOutput.split(/\n/);
        let blame = [];
        let current = {};
        for(let i = 0; i < gitBlameOutput.length; i++)
        {
            let line = gitBlameOutput[i];
            if (/^\t/.test(line))
            {
                blame.push(current);
                current = {};
            }
            else
            {
                let key = line.replace(/^(\S+)\s+.*/,'$1');
                let value = line.replace(/^\S+\s+/,'');
                current[key] = value;
            }
        }
        return blame;
    }

    // Download metadata for an item
    addMetadataTo(collItem)
    {
        throw('collectionType: generic addMetadataTo called: should be overridden by subclass');
    }

    // Download the poster for an item
    addPosterToItem(collItem)
    {
        throw('collectionType: generic addPosterToItem called: should be overridden by subclass');
    }

    // Finalize the collection
    finalizeCollection(data)
    {
        data = this.sortFinalCollection(data);
        for (let collectionEntryI in data)
        {
            data[collectionEntryI].id = collectionEntryI;
        }
        return { 'data':data, 'meta':this.getFinalizedMetadata()};
    }

    // Sort the final collection
    sortFinalCollection(data)
    {
        // Sort
        if(this._entry.defaultSort === undefined || this._entry.defaultSort !== 'year')
        {
            data.sort(function(a,b) {
                    return a.title.localeCompare(b.title);
            });
        }
        else
        {
            data.sort(function(a,b) {
                    if(a.year && b.year && a.year != b.year)
                    {
                        return b.year - a.year;
                    }
                    if(a.year && !b.year)
                    {
                        return -1;
                    }
                    if (!a.year && b.year)
                    {
                        return 1;
                    }
                    return a.title.localeCompare(b.title);
            });
        }
        return data;
    }

    getFinalizedMetadata ()
    {
        for(let metaEntry in this._meta)
        {
            // Filter and deduplicate arrays
            if(Array.isArray(this._meta[metaEntry]))
            {
                // First, sort the array
                let result = this._meta[metaEntry];
                result.sort();
                // Ensure entries are unique
                result = _.uniq(result);
                // Ensure nothing is null or undefined
                result = _.filter(result,
                    function (entry)
                    {
                        return entry !== null && entry !== undefined;
                    }
                );
                // Save our newly deduplicated and filtered array
                this._meta[metaEntry] = result;
            }
        }
        return this._meta;
    }

    // Adds "statically generated" metadata to an item. This includes the item
    // type and source
    addStaticMetadataToItem (collItem)
    {
        collItem.type    = this._entry.type;
        collItem.bSource = this._curBsource;
    }

    // Handles a single item from a source in this collection
    generateEntry (collItem)
    {
        if(this._entry.contentType)
        {
            collItem.contentType = this._entry.contentType;
        }
        this.addStaticMetadataToItem(collItem);
        this.addMetadataTo(collItem);
        this.addPosterToItem(collItem);
    }

    // Handles a single source in this collection
    generateSource (source)
    {
        let data = this.loadData(source);
        for(let collItem of data)
        {
            this.generateEntry(collItem);
        }
        if(source.hasDisneySort)
        {
            this._meta.hasDisneySort = true;
        }
        cache.flushIfNeeded();
        return data;
    }

    // Perform all actions needed to get a full collection datastructure
    generateDatastructure ()
    {
        let entries = [];
        // Walk through all datasources and generate each one
        for(let source of this._entry.sources)
        {
            let contents = this.generateSource(source);
            source.bSource = this._curBsource;
            entries = entries.concat(contents);
        }
        return this.finalizeCollection(entries);
    }

    // Output a warning
    warn(message)
    {
        // FIXME: This should provide information about the entry that's being processed
        // so that the user can find it
        printv(0,'Warning: (unknown location): '+message);
    }
}

class movieCollection extends collectionType
{
    // Parent constructor will call initialize for us after it has done the construction
    initialize ()
    {
        Object.assign(this._meta,
        {
            genres: [],
            formats: [],
            enableNormalized: false,
            fields: {}
        });
    }

    // Adds a poster to a collection entry
    addPosterToItem (collectionEntry)
    {
        let theURL   = this.getPoster(collectionEntry);
        if(!theURL)
        {
            theURL = 'missing.png';
        }
        collectionEntry.poster = encodeURIComponent(path.basename(theURL));
    }

    // Finds and downloads a poster for the provided entry
    getPoster (entry)
    {
        let url;
        let ckey;
        let mTitle = entry.title;
        let type = entry.type;
        if(entry.origTitle)
        {
            mTitle = entry.origTitle;
        }
        ckey = getCacheID(entry,entry.type);
        if(entry.customCover)
        {
            url = entry.customCover;
            delete entry.customCover;
            if (fs.existsSync(helper.resolveOutPath('.images/orig/'+path.basename(url))))
            {
                return url;
            }
        }
        else
        {
            let cached = cache.get('URLs',ckey);
            if(cached !== undefined)
            {
                if(cached == 'MISS')
                {
                    if(! commander.retryMiss)
                    {
                        return;
                    }
                }
                else if (fs.existsSync(helper.resolveOutPath('.images/orig/'+path.basename(cached))))
                {
                    let mapped = cache.get('fileMap',path.basename(cached));
                    if(mapped !== undefined && mapped != cached)
                    {
                        printv(1,'WARNING: CONFLICTING URLs WITH BASENAME '+path.basename(cached)+' ('+cached+' and '+mapped+')');
                    }
                    return cached;
                }
            }
        }
        // Remap type so that movieArt can handle it
        if(type == 'movies')
        {
            type = 'movie';
        }
        else if(type == 'series')
        {
            type = 'tv';
        }
        if(!helper.isValidCoverURL(url))
        {
            if(!helper.isValidCoverURL(url) && entry.imdbID && entry.poster)
            {
                url = entry.Poster;
            }
            if(!helper.isValidCoverURL(url) && entry.year)
            {
                url = this.submitMovieArtRequest(mTitle,entry.year,type);
            }
            if(!helper.isValidCoverURL(url))
            {
                url = this.submitMovieArtRequest(mTitle,null,type);
            }
            if(!helper.isValidCoverURL(url))
            {
                if(type == 'tv')
                {
                    type = 'movie';
                }
                else
                {
                    type = 'tv';
                }
                if(entry.year && !url)
                {
                    url = this.submitMovieArtRequest(mTitle,entry.year,type);
                }
                if(!helper.isValidCoverURL(url))
                {
                    url = this.submitMovieArtRequest(mTitle,null,type);
                }
                if(!helper.isValidCoverURL(url) && entry.poster)
                {
                    url = entry.poster;
                }
            }
        }
        if (helper.downloadAndCacheURL(url,ckey,entry))
        {
            return url;
        }
    }

    // Submits a movieArt request
    submitMovieArtRequest (mTitle,year,type)
    {
        let url;
        printv(5,'Submitting request to movieArt: '+mTitle+','+year+','+type);
        try
        {
            url = wait.for(movieArt,mTitle,year,null,type);
        } catch(e) {}
        return url;
    }

    // Adds metadata to an entry
    addMetadataTo(collectionEntry)
    {
        if(collectionEntry.title == null || !/\S/.test(collectionEntry.title))
        {
            this.warn('has no title entry - skipping it');
            return;
        }
        if(collectionEntry.watched != null)
        {
            collectionEntry.watched      = helper.parseBool(collectionEntry.watched);
        }

        let meta = this.retrieveMetadataFor(collectionEntry);
        if(meta != null)
        {
            if(this.isValidOMDBField(meta.imdbID))
            {
                collectionEntry.imdbID = meta.imdbID;
            }
            if(!collectionEntry.actors && this.isValidOMDBField(meta.Actors))
            {
                collectionEntry.actors = meta.Actors;
            }
            if(this.isValidOMDBField(meta.Metascore))
            {
                collectionEntry.metascore = meta.Metascore;
            }
            if(this.isValidOMDBField(meta.imdbRating))
            {
                collectionEntry.imdbRating = meta.imdbRating;
                collectionEntry.imdbVotes  = meta.imdbVotes;
            }
            if(this.isValidOMDBField(meta.Plot))
            {
                collectionEntry.plot = meta.Plot;
            }
            if(this.isValidOMDBField(meta.Director))
            {
                collectionEntry.director = meta.Director;
            }
            if(this.isValidOMDBField(meta.Writer))
            {
                // Translators: used to translate substrings in the «writer» metadata
                collectionEntry.writer = meta.Writer.replace(/screenplay/g,i18n.translate('screenplay'))
                // Translators: used to translate substrings in the «writer» metadata
                .replace(/(motion picture|movie)/g,i18n.translate('motion picture'))
                // Translators: used to translate substrings in the «writer» metadata
                .replace(/comic( book)?/g,i18n.translate('comic book'))
                // Translators: used to translate substrings in the «writer» metadata
                .replace(/story/g,i18n.translate('story'))
                // Translators: used to translate substrings in the «writer» metadata
                .replace(/novel/g,i18n.translate('novel'))
                // Translators: used to translate substrings in the «writer» metadata
                .replace(/characters/g,i18n.translate('characters'))
                // Translators: used to translate substrings in the «writer» metadata
                .replace(/book/g,i18n.translate('book'));
            }
            if (this._entry.autoGenre &&!collectionEntry.genre && this.isValidOMDBField(meta.Genre))
            {
                collectionEntry.genre = meta.Genre;
            }
            if(!collectionEntry.imdbID && this.isValidOMDBField(meta.imdbID))
            {
                collectionEntry.imdbID = meta.imdbID;
            }
            if(this.isValidOMDBField(meta.Runtime))
            {
                let runtime = meta.Runtime;
                if (/ min/.test(runtime))
                {
                    runtime                    = runtime.replace(/\s+min/,'');
                    collectionEntry.runtimeMin = runtime;
                    let floating               = parseInt(runtime)/60;
                    if(floating > 0)
                    {
                        let hours   = parseInt(floating);
                        let minutes = parseInt((floating-hours)*60);
                        if(hours > 0)
                        {
                            // Translators: Results in [number]h [number]min (ie. X hours and X minutes)
                            runtime = util.format(i18n.translate('%dh %dmin'),hours,minutes);
                        }
                        else
                        {
                            // Translators: Results in [number]min (ie. X minutes)
                            runtime = util.format(i18n.translate('%dmin'),minutes);
                        }
                    }
                }
                collectionEntry.runtime = runtime;
            }
            // This *will* get overridden by addPosterToItem(). It is used so that we can
            // provide a poster URL hint to getPoster().
            if(!collectionEntry.poster && this.isValidOMDBField(meta.Poster))
            {
                collectionEntry.poster = meta.Poster;
            }
        }
        if(collectionEntry.genre)
        {
            this._meta.genres = this._meta.genres.concat(collectionEntry.genre.split(/,\s*/));
        }
        if(collectionEntry.format)
        {
            collectionEntry.format = collectionEntry.format.split(/,\s*/);
            this._meta.formats = this._meta.formats.concat(collectionEntry.format);
        }
        if(collectionEntry.rating)
        {
            this._meta.enableNormalized   = true;
            if(collectionEntry.rating > 6 || collectionEntry.rating < 1)
            {
                printv(1,'Unreasonable rating for "'.collectionEntry.title+'": '+collectionEntry.rating+' (should be 1-6)');
            }
            else
            {
                collectionEntry.normalizedRating = parseInt(collectionEntry.rating*16.7);
                if(collectionEntry.imdbRating)
                {
                    let decimal = parseInt(collectionEntry.imdbRating*10);
                    collectionEntry.normalizedRating = parseFloat(collectionEntry.normalizedRating+'.'+decimal);
                }
            }
        }
        else if(collectionEntry.imdbRating)
        {
            collectionEntry.normalizedRating = parseInt(collectionEntry.imdbRating*10);
        }
        else if(collectionEntry.metascore)
        {
            collectionEntry.normalizedRating = collectionEntry.metascore;
            this._meta.enableNormalized   = true;
        }
        if(meta && !collectionEntry.year && this.isValidOMDBField(meta.Year))
        {
            collectionEntry.year = meta.Year;
        }
        if(collectionEntry.year)
        {
            collectionEntry.sortYear = parseInt(collectionEntry.year);
        }
        collectionEntry.normalizedTitle = helper.normalizeTitle( collectionEntry.origTitle ? collectionEntry.origTitle : collectionEntry.title );
        // FIXME: This is ugly and really shouldn't be here. We should just have an array
        // of included data and call some other method to clean up and then have that
        // method decide if we actually want to clean or not.
        if (!commander.includeDebug)
        {
            let includedData = {
                year: true,
                sortYear: true,
                poster: true,
                type: true,
                bSource: true,
                actors: true,
                metascore: true,
                imdbRating: true,
                imdbVotes: true,
                plot: true,
                director: true,
                writer: true,
                genre: true,
                runtime: true,
                runtimeMin:true,
                origTitle:true,
                title: true,
                seasons: true,
                format: true,
                rating: true,
                note: true,
                altTitle: true,
                contentType:true,
                disneyClassicNo: true,
                imdbID: true,
                watched: true,
                added: true,
                addedRaw: true,
                normalizedTitle: true,
                normalizedRating: true
            };
            for (let field in collectionEntry)
            {
                if (!includedData[field])
                {
                    delete collectionEntry[field];
                }
            }
        }
        helper.storeFieldBools(collectionEntry,this._meta);
    }

    // Fetches metadata from a source for an entry
    retrieveMetadataFor(entry)
    {
        let ckey = getCacheID(entry);
        if (cache.get('meta',ckey))
        {
            if(cache.get('meta',ckey) == 'MISS')
            {
                if(! commander.retryMiss)
                {
                    return;
                }
            }
            else
            {
                if(cache.get('meta',ckey).Response != 'True')
                {
                    cache.unset('meta',ckey);
                }
                return cache.get('meta',ckey);
            }
        }
        let data = this.fetchFromOMDB(entry);
        if(data && data.Response == "False")
        {
            printv(3,'Could not retrieve data from OMDB on '+ (entry.origTitle ? entry.origTitle : entry.title) );
            cache.set('MISS','meta',ckey);
            return;
        }
        if ((entry.type == 'movies' && (!entry.year || parseInt(entry.year) == parseInt(data.Year)))|| (entry.type == 'series' || parseInt(entry.year) == parseInt(data.Year)) || (entry.imdbID && data.imdbID == entry.imdbID) )
        {
            printv(1,'Fetched meta info for '+entry.title);
            cache.set(data,'meta',ckey);
            return data;
        }
        else
        {
            if(entry.year && data.Year != entry.year)
            {
                let diff = entry.year - data.Year;
                if (diff <= 2 && diff >= -2)
                {
                    printv(1,'Discrepancy: '+entry.title+' is marked as released in '+entry.year+' but the OMDB entry claims '+data.Year+' (very similar): ignoring data from server');
                }
                else
                {
                    printv(1,'Discrepancy: '+entry.title+' is marked as released in '+entry.year+' but the OMDB entry claims '+data.Year+': ignoring data from server');
                }
            }
            cache.set('MISS','meta',ckey);
        }
        return;
    }

    /*
     * Downloads data from OMDB and attempts fuzzier searches if no data is
     * found
     */
    fetchFromOMDB(entry)
    {
        let data;
        try
        {
            data = wait.for(this.performOMDBRequest,entry);
        }
        catch(e)
        {
            data = null;
        }
        if(data && data.Response != "False")
        {
            return data;
        }
        if(entry.imdbID)
        {
            // Try a request without imdbID
            data = wait.for(this.performOMDBRequest,{ title: entry.origTitle ? entry.origTitle : entry.title, year: entry.year, type: entry.type });
        }
        if(data && data.Response != "False")
        {
            return data;
        }
        if(entry.origTitle)
        {
            // Try a request without origTitle
            data = wait.for(this.performOMDBRequest,{ title: entry.title, year: entry.year, type: entry.type });
        }
        if(data && data.Response != "False")
        {
            return data;
        }
        if(entry.altTitle)
        {
            data = wait.for(this.performOMDBRequest,{ title: entry.altTitle, type: entry.type });
        }
        if(data && data.Response != "False")
        {
            return data;
        }
        if(entry.year)
        {
            data = wait.for(this.performOMDBRequest,{ title: entry.origTitle ? entry.origTitle : entry.title, type: entry.type });
        }
        if(data && data.Response != "False")
        {
            return data;
        }
        if(entry.type)
        {
            let entryWithoutType = _.cloneDeep(entry);
            delete entryWithoutType.type;
            return this.fetchFromOMDB(entryWithoutType);
        }

        let fixedTitle = helper.attemptGenericReplacements(entry.origTitle ? entry.origTitle : entry.title);
        if(fixedTitle)
        {
            data = wait.for(this.performOMDBRequest,{ title: fixedTitle, year: entry.year });
        }

        return data;
    }

    /*
     * Constructs and submits a single OMDB request
     */
    performOMDBRequest(titleData,cb)
    {
        let url          = 'http://www.omdbapi.com',
            requestQuery = {t: titleData.title, plot: 'short', r: 'json'};
        if(titleData.imdbID)
        {
            delete requestQuery.t;
            requestQuery.i = titleData.imdbID;
        }
        else
        {
            if(titleData.origTitle)
            {
                requestQuery.t = titleData.origTitle;
            }
            if(titleData.year)
            {
                requestQuery.y = parseInt(titleData.year);
            }
            if(titleData.type == 'series')
            {
                requestQuery.type = 'series';
            }
        }
        if(requestQuery.t == null && requestQuery.i == null)
        {
            return cb('t+i are null');
        }
        let serialish = url+JSON.stringify(requestQuery);
        if(runtimeCache[serialish])
        {
            cb(null,_.clone(runtimeCache[serialish],true));
            return;
        }
        printv(4,'Performing OMDB request: '+ (requestQuery.t ? requestQuery.t : requestQuery.i ));
        printv(8,'Request key: '+serialish);
        httpreq.get(url, {
                parameters: requestQuery
            },function (err,res)
            {
                if (!err)
                {
                    try
                    {
                        res = JSON.parse(res.body);
                        runtimeCache[serialish] = _.clone(res,true);
                    }
                    catch(e)
                    {
                        err = e;
                    }
                }
                cb(err,res);
            }
        );
    }

    /*
     * Checks if a field from OMDB is valid (they can be undefined or the
     * string 'N/A' if invalid)
     */
    isValidOMDBField (content)
    {
        if(content !== undefined && content !== 'N/A')
        {
            return true;
        }
        return false;
    }
}

class gameCollection extends collectionType
{
    // Parent constructor will call initialize for us after it has done the construction
    initialize ()
    {
        this._steamAPIErrLimitReached = false;
        Object.assign(this._meta,
        {
            genres: [],
            platforms: [],
            fields: {}
        });
    }

    // Overrides the loadData() method, because games have a special "steam" source
    loadData(source)
    {
        if(source.source && source.source == 'steam')
        {
            return this.loadSteamData(source);
        }
        else
        {
            return this.loadCSVData(source);
        }
    }

    // Loads Steam data
    loadSteamData(source)
    {
        let user = source.user,
            ckey = 'steam//games//'+user,
            now  = Math.floor(Date.now() / 1000);
        this._curBsource = 'steam/'+user;
        printv(3,'Interpreting steam collection for "'+user+'"');
        if(cache.get('arbitrary',ckey))
        {

            let lastUpdated = cache.get('arbitrary',ckey+'//_lastUpdated');
            if(lastUpdated !== undefined && lastUpdated > (now - (82800*7) ) && !commander.forceSteamUpdate)
            {
                printv(5,'Using cached Steam data for '+user);
                return cache.get('arbitrary',ckey);
            }
            else
            {
                printv(2,'Updating Steam data for '+user);
            }
        }
        let data = wait.for(steam.gamesFromProfile,user),
            resultData = [];
        for(let entry of data)
        {
			if (
				// Ignore DLC and season passes
				/\s(DLC|[Ss]eason\s+[Pp]ass)/.test(entry.title) ||
				// Other DLC matches
				/\s((Map|Texture)\s*Pack)(\s*\d*)?$/.test(entry.title) ||
				// Ignore games returned from Steam with completely wrong
				// names
				/^\s*(Limited\s*Edition)\s*$/i.test(entry.title)
			)
            {
                continue;
            }

            entry.steamUser = user;
            entry.title    = entry.name;
            entry.steamID  = entry.appid;
            entry.format   = 'Steam';
            resultData.push(entry);
        }
        this.retrieveSteamMetadata(data,user);
        cache.set(now,'arbitrary',ckey+'//_lastUpdated');
        cache.set(resultData,'arbitrary',ckey);
        return resultData;
    }

    /*
     * Fetches some deep keys if they are available, or undefined if it
     * can not be found. Also returns data in a specified format
     */
    deepFetch(type, source, rabbitHole)
    {
        for(let entry of rabbitHole)
        {
            if(source !== null && source[entry])
            {
                source = source[entry];
            }
            else
            {
                source = null;
                break;
            }
        }
        if(type == 'array')
        {
            return this.mustBeArray(source);
        }
        throw('Unhandled type: '+type);
    }

    /*
     * Handles metadata preparation and mapping for *any* game
     */
    addMetadataTo(collItem)
    {
        let meta = this.getGameMetadata(collItem);
        if(meta)
        {
            let genres = [];
            if(collItem.genres)
            {
                genres = collItem.genres.split(/,s\*/);
            }
            else if(meta.steamGenres)
            {
                for(let genre of meta.steamGenres)
                {
                    genres.push(genre.description);
                }
            }
            else
            {
                genres = this.deepFetch('array',meta,['Genres','genre']);
            }
            if (collItem.year)
            {
                collItem.sortYear = parseInt(collItem.year);
            }
            else if(meta.ReleaseDate)
            {
                collItem.year = meta.ReleaseDate.split('/')[2];
                collItem.sortYear = collItem.year;
            }
            else if(meta.steamRelDate)
            {
                collItem.Year = meta.steamRelDate.date.replace(/^\S+\s+\S+\s+/,'');
                collItem.sortYear = collItem.year;
            }
            collItem.genre        = genres.join(', ');
            if(meta.steamOverview)
            {
                collItem.plot         = this.plotCleanAndLimit(collItem.steamOverview);
                if(!collItem.plot || collItem.plot.length === 0 || !/\S/.test(collItem.plot))
                {
                    collItem.plot = null;
                }
            }
            if (!collItem.platform && meta.steamPlatforms)
            {
                collItem.platform = meta.steamPlatforms;
            }
            if (!collItem.plot)
            {
                collItem.plot         = this.plotCleanAndLimit(meta.Overview);
            }
            if (!collItem.developer)
            {
                collItem.developer    = this.mustBeString(meta.Developer);
            }
            collItem.tgdbID       = meta.id;
            if(meta.metacritic != null && meta.metacritic.score != null)
            {
                collItem.metascore = meta.metacritic.score;
            }
            this._meta.platforms = this._meta.platforms.concat(collItem.platform);
            this._meta.genres = this._meta.genres.concat(genres);
        }
        if (!_.isArray(collItem.platform))
        {
            collItem.platform = [ this.doPlatformRemap(collItem.platform,true) ];
        }
        collItem.poster   = this.getPosterURLFromData(collItem,meta);
        collItem.type     = 'game';
        helper.storeFieldBools(collItem,this._meta);
        collItem.normalizedTitle = this.performNameReplacements(helper.normalizeTitle( collItem.origTitle ? collItem.origTitle : collItem.title ));
    }

    // Adds a poster to a collection entry
    addPosterToItem (collectionEntry)
    {
        let theURL;
        if(collectionEntry.poster)
        {
            let ckey = getCacheID(collectionEntry,'game');
            if (helper.downloadAndCacheURL(collectionEntry.poster,ckey,collectionEntry))
            {
                theURL = collectionEntry.poster;
            }
        }
        else
        {
            theURL = 'missing.png';
        }
        collectionEntry.poster = encodeURIComponent(path.basename(theURL));
    }

    getPosterURLFromData(collectionItem,metadata)
    {
        try
        {
            if(metadata === undefined)
            {
                metadata = {};
            }
            let image;
            if(metadata.GameTitle)
            {
                metadata.title = metadata.GameTitle;
            }
            else if(collectionItem.title)
            {
                metadata.title = collectionItem.title;
            }
            if(metadata && metadata.Images && metadata.Images.boxart)
            {
                let iter = this.mustBeArray(metadata.Images.boxart);
                for (let img of iter)
                {
                    image = img['$t']; // jshint ignore:line
                    if(img.side == 'front')
                    {
                        break;
                    }
                }
                if(image && metadata.baseImgUrl)
                {
                    image = metadata.baseImgUrl+image;
                }
            }
            else if(metadata && metadata.header_image)
            {
                image = metadata.header_image;
            }
            else if(collectionItem && collectionItem.appid)
            {
                image = collectionItem.logo;
            }
            return image;
        }
        catch (e)
        {
            if(e.stack)
            {
                printv(1,'Error while finding poster for '+metadata.title+': '+e.stack);
            }
            else
            {
                printv(1,'Error while finding poster for '+metadata.title+': '+e);
            }
        }
        return;
    }

    // We override finalizeCollection so that we can deduplicate our list
    // Parent's finalizeCollection is still used as well
    finalizeCollection(data)
    {
        let seen = {};
        let finalEntries = [];
        // Deduplicate
        for (let collectionEntry of data)
        {
            let ckey = getCacheID(collectionEntry);
            if(seen[ckey] === undefined)
            {
                seen[ckey] = collectionEntry;
                finalEntries.push(collectionEntry);
            }
            else
            {
                seen[ckey].bSource += ', '+collectionEntry.bSource;
            }
        }
        return super.finalizeCollection(finalEntries);
    }

    /*
     * Downloads metadata about games from Steam
     *
     * FIXME: This function really shouldn't exist. The logic should all be
     * handled by getGameInfoFromSteam, including making the requests. That
     * will reduce the load on Steam (we will spend longer between requests),
     * and will make the code more self-contained. We can just store our rate
     * limiting as an attribute on the class instead of in the function.
     */
    retrieveSteamMetadata(games,name)
    {
        let apiLimiter = 0,
            errLimit   = 0,
            steamSleep = 30,
            messagePrinted = false,
            downloaded = 0;
        if(this._steamAPIErrLimitReached)
        {
            return;
        }
        for(let i = 0; i < games.length; i++)
        {
            let appid = games[i].appid;
            if(cache.get('steamMeta',appid) === undefined)
            {
                if (!messagePrinted)
                {
                    printv(1,'Now performing Steam queries for '+name+'. This can take a long time the first time it happens');
                    messagePrinted = true;
                }
                apiLimiter++;
                if(apiLimiter >= 30)
                {
                    apiLimiter = 0;
                    printv(2,'Sleeping 10 seconds to avoid Steam API limits.');
                    printv(1,'Status: processed '+ (i + 1)+' of '+games.length+' games for '+name);
                    cache.write();
                    helper.sleep(10);
                }
                let data = helper.GETJSON('http://store.steampowered.com/api/appdetails?appids='+appid+'&filters=basic,developers,genres,metacritic,platforms,controller_support,release_date');
                let useful = false;
                if(data)
                {
                    downloaded++;
                    errLimit = 0;
                    if(data[appid].success)
                    {
                        cache.set(data[appid].data,'steamMeta',appid);
                    }
                    else
                    {
                        cache.set('MISS','steamMeta','MISS');
                    }
                }
                else
                {
                    errLimit++;
                    i--;
                    cache.write();
                    if(errLimit > 5)
                    {
                        printv(1,'Aborting Steam retrieval for now, error limit exceeded.');
                        printv(1,'This can happen from time to time due to request limits on Steam.');
                        printv(1,'Try again a bit later.');
                        this._steamAPIErrLimitReached = true;
                        return;
                    }
                    printv(1,'Sleeping '+steamSleep+' seconds to allow the Steam API limits to reset [retry '+errLimit+' of 5]');
                    helper.sleep(steamSleep);
                    if(steamSleep < 120)
                    {
                        steamSleep += 30;
                    }
                    else
                    {
                        steamSleep += 10;
                    }
                }
            }
        }
        if(downloaded > 0)
        {
            printv(2,'Steam fetching done for '+name);
        }
    }

    /*
     * Returns Steam metadata if it exists
     */
    getGameInfoFromSteam(game)
    {
        return cache.get('steamMeta',game.steamID);
    }

    /*
     * Remaps game platform names, either to pretty versions or to the versions
     * used by TheGamesDB
     */
    doPlatformRemap(platform,pretty)
    {
        if(Array.isArray(platform))
        {
            let result = [];
            for (let entry of platform)
            {
                result.push( this.doPlatformRemap(entry) );
            }
            return result;
        }
        let platforms = {
            'playstation 2':'Sony Playstation 2',
            'playstation 3':'Sony Playstation 3',
            'playstation 4':'Sony Playstation 4',
            'playstation':'Sony Playstation',
            'wii':'Nintendo Wii',
            'gamecube':'Nintendo GameCube',
            'psx':'Sony Playstation',
            'ps1':'Sony Playstation',
            'ps2':'Sony Playstation 2',
            'ps3':'Sony Playstation 3',
            'ps4':'Sony Playstation 4',
            'psp':'Sony PSP',
            'vita':'Sony Playstation Vita',
            'psvita':'Sony Playstation Vita',
            'n64':'Nintendo 64',
            // Yes, this hurts me as well, but it's, sadly, needed
            'windows':'PC',
            'linux':'PC',
            'mac':'PC',
            'steam':'PC',
            'origin':'PC',
            'gog':'PC',
            'pce':'TurboGrafx 16',
            'tg16':'TurboGrafx 16',
            'tg-16':'TurboGrafx 16',
            'nes':'Nintendo Entertainment System (NES)',
            'snes':'Super Nintendo (SNES)',
            'super nintendo':'Super Nintendo (SNES)',
            'nintendo entertainment system':'Nintendo Entertainment System (NES)',
            'smd':'Sega Mega Drive',
        };
        if(pretty)
        {
            platforms = {
                'playstation 2':'PS2',
                'playstation 3':'PS3',
                'sony playstation 2':'PS2',
                'sony playstation 3':'PS3',
                'sony playstation 4':'PS4',
                'sony playstation vita':'PSVita',
                'nintendo entertainment system (nes)':'NES',
                'sony psp':'PSP',
                'playstation':'PS1',
                'sony playstation':'PS1',
                'nintendo wii':'Wii',
                'nintendo 64':'N64',
                'nintendo gamecube':'GameCube',
                'turbografx 16':'TG-16',
                'pce':'TG-16',
                'super nintendo (snes)':'SNES',
                'sega mega drive':'SMD',
            };
        }
        if(platform != null)
        {
            let platLower = platform.toLowerCase();
            if(platforms[platLower])
            {
                return platforms[platLower];
            }
        }
        return platform;
    }

    /*
     * Downloads and merges metadata from TheGamesDB and SteamDB
     */
    getGameMetadata(game)
    {
        let baseMeta = this.getGameInfoFromTGD(game);
        if(game.steamID)
        {
            if(baseMeta == null)
            {
                baseMeta = {};
            }
            let steamMeta = this.getGameInfoFromSteam(game);
            if(steamMeta)
            {
                baseMeta.steamOverview = steamMeta.about_the_game;
                baseMeta.header_image  = steamMeta.header_image;
                baseMeta.metacritic    = steamMeta.metacritic;
                baseMeta.Developer     = steamMeta.developers;
                baseMeta.steamRelDate  = steamMeta.release_date;
                baseMeta.steamGenres   = steamMeta.genres;
                baseMeta.platforms     = steamMeta.platforms;
                baseMeta.steamID       = steamMeta.steam_appid;
                baseMeta.steamPlatforms = [];
                if(steamMeta.platforms)
                {
                    if(steamMeta.platforms.linux)
                    {
                        baseMeta.steamPlatforms.push('Linux');
                    }
                    if(steamMeta.platforms.windows)
                    {
                        baseMeta.steamPlatforms.push('Windows');
                    }
                    if(steamMeta.platforms.mac)
                    {
                        baseMeta.steamPlatforms.push('Mac');
                    }
                }
                else
                {
                    baseMeta.steamPlatforms.push('Windows');
                }
                if(baseMeta.Platform != 'PC')
                {
                    baseMeta.Platform = 'PC';
                    // Disable use of images about games on other platforms
                    if(steamMeta.header_image)
                    {
                        delete baseMeta.Images;
                    }
                }
            }
        }
        return baseMeta;
    }

    /*
     * Cleans up (by parsing html entities) and limits the length of a plot
     */
    plotCleanAndLimit (plot)
    {
        if(plot !== undefined)
        {
            // The double decode here is intentional, Steam's data is oddly
            // double-encoded
            plot = he.decode(he.decode(plot.replace(/<[uo]l[^>]+>/g,"\n- ").replace(/([^\.\!\,])<\/[uo]l>/g,'$1.').replace(/<br\s*\/?>/g,"\n").replace(/<[^>]+>/g,'')));
            if(plot.length >= 200)
            {
                plot = plot.replace(/\n\n/,'. ');
                let split = plot.split(" ");
                plot = '';
                let currentSentence = [];
                for(let comp of split)
                {
                    currentSentence.push(comp);
                    if (/[\?\!\.]$/.test(comp))
                    {
                        if(plot.length > 0)
                        {
                            plot += ' ';
                        }
                        plot += currentSentence.join(' ');
                        if(plot.length > 200)
                        {
                            break;
                        }
                        currentSentence = [];
                    }
                }
                return plot+' [...]';
            }
        }
        return plot;
    }

    /*
     * Cleans up a game name, removing various markers that can prevent
     * us finding it in the metadata database, like "GOTY", "Remastered",
     * "Premium", "HD", "Director's cut", "early access", "for [platform]"
     * and so on. This gets triggered if retrieval of the full name fails.
     */
    performNameReplacements(on,doAll,excludeGeneric)
    {
        let orig = on;
        on = on.replace(/([:-]?\s*)\(?((the|steam|new|old)\s+)?(Black|Steam|Linux|Windows|Mac(\s*OS\s*X?)?|EU|PAL|NTSC|US|PS\s*Vita|Special|Collector[`’']?s?|Remastered|Game of the year|Complete|Enhanced|Ultimate|Gold|Extreme|Epic|Uber|Deluxe|Premium|HD|GOTY|Developer|Director|Final|Special|Ultimate|Extended|Anniversary)(\s+\S+)?\s+(journey|edition|version|cut|collection)\)?\s*(upgrade)?/ig,'')
            .replace(/\s*for\s*(Linux|Windows|Mac|PC)/i,'')
            .replace(/\s*(Linux|Windows|Mac|PC|Playstation|Playstation Vita|PS\s*Vita)\s*(Edition|Version)?$/i,'')
            .replace(/GOTY/,'')
            .replace(/[:-]?\s*(Classic|(Un)?stable|(Beta|Alpha)(\s*test)?|Deluxe|Gold|Linux|Mac(\s*OS\s*X?)?|Windows|Redux|Remaster(ed)?|HD|Complete|Trilogy|Collection)\s*$/gi,'')
            .replace(/[:-]?\s*(Single|Multi)\s*player/gi,'')
            .replace(/\([^\)]+\)/,'')
            .replace(/Sid Meier\'s\s*/gi,'')
            .replace(/\+/g,'')
            .replace(/[:-]?\s*(Ep(isode)?|Chapter)\s*\d+.*/,'')
            .replace(/\s*Early\s*Access/gi,'')
            .replace(/\s*start(er)?\s*pack/gi,'')
            .replace(/[:-]?\s*(Game\s*of\s*the\s*year\s*)/gi,'')
            .replace(/free[\s-]*(2|to)[\s-]*play/ig,'')
            // This removes additional data from games with multiple names, ie. "Resident Evil 5 / Biohazard 5" -> " Resident Evil 5"
            .replace(/\s+\/\s+.+/,'');
        if( (on == orig || doAll) && !excludeGeneric)
        {
            let generic = helper.attemptGenericReplacements(on);
            if(generic)
            {
                on = generic;
            }
            on = on.replace(/^The\s*/,'');
        }
        if(on == orig || doAll)
        {
            on = on.replace(/[,\.-\/]/g,' ');
        }
        if(on == orig || doAll)
        {
            // Converts "CamelCaseName" to "Camel Case Name"
            on = on.replace(/([a-z])([A-Z])/g,'$1 $2');
        }
        if(on === "")
        {
            return orig;
        }
        if(on != orig)
        {
            printv(8,'performNameReplacements: Converted "'+orig+'" to "'+on+'"');
        }
        return on.replace(/\s+/g,' ');
    }

    /*
     * Performs requests from TGD, getting fuzzier until it either finds an
     * entry or fails
     */
    getGameInfoFromTGD(game)
    {
        let ckey = getCacheID(game,'game', { ignoreSteam: true });
        if(cache.get('gameMeta',ckey))
        {
            if(cache.get('gameMeta',ckey) == 'MISS')
            {
                if(! commander.retryMiss)
                {
                    return;
                }
            }
            else
            {
                return cache.get('gameMeta',ckey);
            }
        }
        let data = this.fetchDataFromTGD(game,ckey),
            newName;
        if (!data)
        {
            newName = helper.attemptGenericReplacements(game.title,false);
            if(newName != game.title && newName !== null)
            {
                data = this.fetchDataFromTGD({
                        title: newName,
                        steamID: game.steamID,
                        platform: game.platform
                },ckey);
            }
        }
        if (!data)
        {
            newName = this.performNameReplacements(game.title,true);
            if(newName != game.title && newName !== null)
            {
                data = this.fetchDataFromTGD({
                        title: newName,
                        steamID: game.steamID,
                        platform: game.platform
                },ckey);
            }
        }
        if (!data)
        {
            newName = this.performNameReplacements(game.title,true,true);
            if(newName != game.title && newName !== null)
            {
                data = this.fetchDataFromTGD({
                        title: newName,
                        steamID: game.steamID,
                        platform: game.platform
                },ckey);
            }
        }
        if (!data)
        {
            newName = this.performNameReplacements(game.title);
            if(newName != game.title && newName !== null)
            {
                data = this.fetchDataFromTGD({
                        title: newName,
                        steamID: game.steamID,
                        platform: game.platform
                },ckey);
            }
        }
        if (!data)
        {
            data = this.fetchDataFromTGD({
                    title: game.title,
            },ckey);
        }
        if (!data)
        {
            data = this.fetchDataFromTGD({
                    title: newName,
            },ckey);
        }
        if(data)
        {
            printv(1,'Fetched meta info for '+ game.title );
        }
        else
        {
            printv(1,'Could not fetch metadata for '+ game.title);
        }
        return data;
    }

    /*
     * Download data from TGD, attempting to match it with the provided game
     * data. Entries are then scored, and the best entry (if any) gets
     * returned.
     */
    fetchDataFromTGD(game,ckey)
    {
        let search = this.TGD_search(game.title),
            meta;
        if (!search)
        {
            cache.set('MISS','gameMeta',ckey);
            return;
        }
        let platform = this.doPlatformRemap(game.platform);
        if(game.steamID)
        {
            platform = 'PC';
        }
        if(platform != null)
        {
            platform = platform.toLowerCase();
        }
        let name = game.title;
        if(name == null)
        {
            throw('fetchDataFromTGD got NULL title');
        }
        /*
         * Pre-process GameTitle
         */
        for(let replyPreProcess of search)
        {
            replyPreProcess.GameTitle = he.decode(replyPreProcess.GameTitle);
        }
        let filteredName = name.replace(/(™|®|©|\(TM\)|\(R\)|\(C\))/g,'');
        for(let response of search)
        {
            let points = 0;

            if(platform && this.doPlatformRemap(response.Platform).toLowerCase() != platform)
            {
                response.score = 0;
                continue;
            }

            if(response.GameTitle == game.title)
            {
                points += 20;
            }
            else if(response.GameTitle.toLowerCase() == game.title.toLowerCase())
            {
                points += 10;
            }
            else if(response.GameTitle.toLowerCase().indexOf(filteredName.toLowerCase()) != -1)
            {
                points += 6;
            }
            else
            {
                let prevLoc = -1,
                    gtLower = response.GameTitle.toLowerCase();
                for(let bit of filteredName.toLowerCase().split(/\s+/))
                {
                    // The substr is to make sure we only check for instaces
                    // later in the string than the previous one (so that the
                    // order of the words is preserved, otherwise we'd get a
                    // lot of strange hits)
                    let idx = gtLower.substr(prevLoc+1).indexOf(bit);
                    if(idx === -1)
                    {
                        bit = bit.replace(/\W/,'');
                        if(bit.length === 0)
                        {
                            continue;
                        }
                        idx = gtLower.substr(prevLoc+1).indexOf(bit);
                    }
                    if(idx !== -1)
                    {
                        prevLoc = idx;
                    }
                    else
                    {
                        prevLoc = -1;
                        break;
                    }
                }
                // We're being a bit picky here in that if we get the wrong platform (or no platform)
                // and the title is much longer than ours, we probably want to skip it
                if (prevLoc != -1 && !platform && response.GameTitle.length >= (name.length*1.6))
                {
                    // We try a final test here. We perform all relevant replacements on both the
                    // requested name and the response name. Then we see if the response is within
                    // the limts after performing those replacements. If it is then we grant it
                    // a single point. This is to be able to handle responses
                    // that include ie. "limited edition" for short titles.
                    let replacedGT = this.performNameReplacements(response.GameTitle,false,true),
                        replacedName = this.performNameReplacements(name,false,true);
                    if(replacedGT.length < (replacedName.length*1.6) && replacedName.length <= replacedGT.length)
                    {
                        printv(5,'Got a fuzzy hit on "'+response.GameTitle+'" for "'+name+'". The length is over 1.6x that of the requested one (and has no platform match). Granting 1 point because it was within limits after performing replacements.');
                        points = 1;
                    }
                    else
                    {
                        // Still no hit, so we give it a score of 0 points
                        printv(5,'Got a fuzzy hit on "'+response.GameTitle+'" for "'+name+'". Ignoring due to the length being over 1.6x that of the requested one (and no platform match)');
                        points = 0;
                    }
                }
                else if(prevLoc != -1)
                {
                    // We grant 1.5 points for unreasonably long titles, and 3
                    // points for closer matches
                    if (response.GameTitle.length >= (name.length*1.6))
                    {
                        points += 1.5;
                    }
                    else
                    {
                        points += 3;
                    }
                }
            }
            // If the name doesn't match nothing else matters
            if(points === 0)
            {
                response.score = points;
                continue;
            }
            if(response.ReleaseDate && response.ReleaseDate.length)
            {
                let year = response.ReleaseDate.split('/')[2];
                if (game.year && year == game.year)
                {
                    points += 3;
                }
            }

            response.score = points;
        }
        search = search.sort(function(a,b) {
                return b.score - a.score;
        });
        while(search.length > 0)
        {
            let best = search.shift();
            if(best.score > 0)
            {
                meta = this.TGD_infoByID(best.id);
                if(meta !== undefined)
                {
                    cache.set(meta,'gameMeta',ckey);
                    return meta;
                }
            }
        }
        cache.set('MISS','gameMeta',ckey);
        return;
    }

    /*
     * Retrieves a complete entry from TGD, by its TGD id number
     */
    TGD_infoByID(id)
    {
        let result = this.TGD_request('GetGame',{ id: id});
        if(result && result.Data && result.Data.Game)
        {
            result.Data.Game.baseImgUrl = result.Data.baseImgUrl;
            return result.Data.Game;
        }
        return;
    }

    /*
     * Performs a TGD search
     */
    TGD_search(game)
    {
        let result = this.TGD_request('GetGamesList',{ name: game });
        if(result && result.Data && result.Data.Game)
        {
            return this.mustBeArray(result.Data.Game);
        }
        return;
    }

    /*
     * Constracts a request for GD
     */
    TGD_request(call,parameters)
    {
        let rqURL = 'http://thegamesdb.net/api/'+call+'.php?',
            finalParams = [],
            result;
        for(let key in parameters)
        {
            finalParams.push(encodeURIComponent(key)+'='+encodeURIComponent(parameters[key]));
        }
        rqURL += finalParams.join('&');
        result = this.XMLtoJSONRequest(rqURL);
        return result;
    }

    /*
     * Performs a HTTP request that returns XML and then converts it to a
     * JSON-style object.
     *
     * FIXME: This should be moved to the parent class
     */
    XMLtoJSONRequest(url)
    {
        if(runtimeCache[url])
        {
            return _.clone(runtimeCache[url],true);
        }
        printv(4,'Performing XMLtoJSONRequest to: '+url);
        let data;
        try
        {
            data = wait.forMethod(httpreq,'get',url);
        }
        catch(e)
        {
            printv(1,'Got error while performing an XMLtoJSONRequest to "'+url+'": '+e.message);
        }
        try
        {
            data = xml2json.toJson(data.body);
        }
        catch(e)
        {
            // Errors might mean malformed XML, just return nothing
            return;
        }
        let result = JSON.parse(data);
        runtimeCache[url] = _.clone(result,true);
        return result;
    }

    /*
     * Convers thing into an array if it isn't already
     *
     * FIXME: This should be moved to the parent class
     */
    mustBeArray(thing)
    {
        if (!_.isArray(thing))
        {
            return [ thing ];
        }
        return thing;
    }

    /*
     * Converts thing to a string if it isn't already
     *
     * FIXME: This should be moved to the parent class
     */
    mustBeString(thing)
    {
        if(thing === undefined)
        {
            return thing;
        }
        if (_.isArray(thing))
        {
            return thing.join(', ');
        }
        if(typeof(thing) != "string")
        {
            if(thing.toString)
            {
                return thing.toString();
            }
            throw('Unable to ensure that "'+thing+'" is a string');
        }
        return thing;
    }
}

/*
 * Various helper functions for the rest of the program
 */
var helper = {
    /*
     * Downloads a URL synchronously and returns the JSON data from it
     */
    GETJSON: function (url)
    {
        if(commander.lazy)
        {
            return;
        }
        printv(4,'Performing GET request for JSON to '+url);
        let data;
        try
        {
            data = wait.forMethod(httpreq,'get',url);
        }
        catch(e)
        {
            printv(5,'Exception while performing request: '+e.message);
            return null;
        }
        if (data.body == 'null')
        {
            printv(5,'URL returned literal null');
            return;
        }
        try
        {
            let req = JSON.parse(data.body);
            printv(5,'Successfully parsed JSON');
            return req;
        }
        catch(e)
        {
            printv(5, 'Error during JSON parsing: '+e.message);
            return;
        }
    },
    /*
     * Remaps fields on an object (CSV-file) from various variations that we
     * accept into the actual fields we use internally
     */
    remapCSVFields: function (content)
    {
        let map = {
            'Tittel':'title',
            'Namn':'title',
            'Plattform':'platform',
            'Sesongar':'seasons',
            'Sesonger':'seasons',
            'Original Tittel':'origTitle',
            'Original tittel':'origTitle',
            'Årstall':'year',
            'Sjanger':'genre',
            'Format':'format',
            'Klassikernummer':'disneyClassicNo',
            'Lagt til':'added',
            'Kover':'customCover',
            'Sett':'watched',
            'Cover':'customCover',
            'Skuespillere':'actors',
            'Omslag':'customCover',
            'Alternativ tittel':'altTitle',
            'Alternativ Tittel':'altTitle',
            'IMDB ID':'imdbID',
            'Rating':'rating',
            'Terningkast':'rating',
            'Notat':'note'
        };
        // Remap according to the mapping table
        for(let key in map)
        {
            let sourceKey = key;
            if(content[key] === undefined)
            {
                sourceKey += ':';
            }
            if(content[sourceKey] !== undefined)
            {
                if(content[sourceKey].length)
                {
                    content[ map[key] ] = content[sourceKey];
                }
                delete content[sourceKey];
            }
        }
        // Lowercase unmapped keys
        for(let key in content)
        {
            if(key === "")
            {
                printv(1,'Warning: '+content.title+' has an empty key ("")');
                continue;
            }
            if (/^[A-Z]/.test(key))
            {
                content[key.toLowerCase()] = content[key];
                delete content[key];
            }
        }
    },
    /*
     * Parses and sets the "added" field
     */
    handleGenericFields: function(content)
    {
        if(content.added)
        {
            content.addedRaw = content.added;
            content.added = Math.round(Date.parse(content.added)/1000);
        }
        else
        {
            content.added = 0;
        }
    },
    /*
     * Does some generic replacements on a title, converting roman numerals to
     * the Arabic numerals (and the other way around), and converting & to and
     * or and to &
     */
    attemptGenericReplacements: function (origTitle)
    {
        if(origTitle == null)
        {
            throw('attemptGenericReplacements got null origTitle');
        }
        let fixedTitle;
        let replacements = [
            {
                index: 'III',
                replacement: '3',
                regex: /III/
            },
            {
                index: '3',
                replacement: 'III',
                regex: /3/
            },
            {
                index: 'II',
                replacement: '2',
                regex: /II/
            },
            {
                index: '2',
                replacement: 'II',
                regex: /2/
            },
            {
                index: 'IV',
                replacement: '4',
                regex: /IV/
            },
            {
                index: '4',
                replacement: 'IV',
                regex: /4/
            },
            {
                index: ' and ',
                replacement: ' & ',
                regex: / and /
            },
            {
                index: ' & ',
                replacement: ' and ',
                regex: / & /
            },
            {
                index: ' 1:',
                replacement: ' I:',
                regex: / 1:/
            },
            {
                index: 'two',
                replacement: '2',
            },
            {
                index: 'three',
                replacement: '3',
            },
            {
                index: 'four',
                replacement: '4',
            },
            {
                index: 'five',
                replacement: '5',
            },
        ];
        for (let attempt of replacements)
        {
            if(origTitle.indexOf(attempt.index) != -1)
            {
                return origTitle.replace(attempt.regex,attempt.replacement);
            }
        }
        return null;
    },
    /*
     * Performs some simple replacements to remove entities from a title
     * that obviously isn't suppose to be there
     */
    normalizeTitle: function (origTitle)
    {
        return origTitle.replace(/\s*™/,'');
    },
    /*
     * Downloads a URL to a file and caches some metadata for it
     *
     * Used for poster downloading.
     */
    downloadAndCacheURL: function (url,ckey,entry)
    {
        if(!helper.isValidCoverURL(url))
        {
            printv(1,'Failed to retrieve poster for '+entry.title+( entry.origTitle ? ' ('+entry.origTitle+')' : ''));
            cache.set('MISS','URLs',ckey);
            return;
        }
        if(ckey == null || ckey === "")
        {
            console.log('WARNING: downloadAndCacheURL received null/empty ckey');
        }
        if (!fs.existsSync(helper.resolveOutPath('.images/orig/'+path.basename(url))))
        {
            cache.set(url,'URLs',ckey);
            if(commander.lazy)
            {
                return;
            }
            if (cache.get('fileMap',path.basename(cache.get('URLs',ckey))) !== undefined && cache.get('fileMap',path.basename(cache.get('URLs',ckey))) != cache.get('URLs',ckey))
            {
                printv(1,'WARNING: CONFLICTING URLs WITH BASENAME '+path.basename(cache.get('URLs',ckey))+' ('+cache.get('URLs',ckey)+' and '+cache.get('fileMap',path.basename(cache.get('URLs',ckey)))+')');
            }
            else
            {
                printv(4,'Downloading: '+url+' to '+'.images/orig/'+path.basename(url));
                let data = wait.forMethod(httpreq,'get',url, {binary: true });
                if(data.statusCode === 200)
                {
                    fs.writeFileSync(helper.resolveOutPath('.images/orig/'+path.basename(url)),data.body);
                    printv(1,'Downloaded poster for '+entry.title);
                }
                else
                {
                    printv(1,'Failed to download poster from '+url+': '+data.statusCode);
                    return;
                }
            }
        }
        if (!cache.get('fileMap',path.basename(cache.get('URLs',ckey))))
        {
            cache.set(url,'fileMap',path.basename(cache.get('URLs',ckey)));
        }
        return true;
    },
    /*
     * Checks if url is a valid url to a cover
     */
    isValidCoverURL: function (url)
    {
        if (url == null || !/^http/.test(url) || /originalnull/i.test(url))
        {
            return false;
        }
        return true;
    },
    /*
     * Resolve the path to a file relative to our source directory
     */
    resolvePath: function(file)
    {
        return __dirname+'/'+file;
    },
    /*
     * Resolve a path relative to our output directory
     */
    resolveOutPath: function(file)
    {
        if(outputDir === null)
        {
            if(commander.config)
            {
                outputDir = path.dirname(commander.config);
            }
            else if(fs.existsSync(process.cwd()+'/rotcelloc.config.cson'))
            {
                outputDir = process.cwd();
            }
            else
            {
                outputDir = __dirname;
            }
            outputDir = fs.realpathSync(outputDir);
            printv(5,'Resolved output directory to '+outputDir);
        }
        return outputDir+'/'+file;
    },
    /*
     * Return the config datastructure
     */
    getConfig: function ()
    {
        if(runtimeCache.__config)
        {
            return runtimeCache.__config;
        }
        let configCSON = helper.resolveOutPath('rotcelloc.config.cson'),
            config;
        if(commander.config)
        {
            configCSON = commander.config;
            if (!fs.existsSync(configCSON))
            {
                console.log(configCSON+': does not exist');
                process.exit(1);
            }
        }
        else if (!fs.existsSync(configCSON))
        {
            printv(4,helper.resolveOutPath('rotcelloc.config.cson')+': does not exist');
            console.log('Error: you must configure rotcelloc first (or provide a --config). Aborting.');
            console.log('See the user guide in README.md');
            process.exit(1);
        }
        try
        {
            config  = CSON.parse(fs.readFileSync(configCSON));
        }
        catch(e)
        {
            throw('Failed to parse rotcelloc.config.cson: '+e.stack);
        }
        runtimeCache.__config = config;
        return config;
    },
    /*
     * Check if a command is available in PATH
     */
    inPath: function (command)
    {
        for(let directory of process.env.PATH.split(':'))
        {
            // This should also check if it is executable
            if(fs.existsSync(directory+'/'+command))
            {
                return true;
            }
        }
        return false;
    },
    /*
     * Parse a boolean-ish string
     */
    parseBool: function (boolStr)
    {
        boolStr = boolStr.toLowerCase();
        // Translators: Used in boolean values in files
        if(boolStr === 1 || boolStr == 'true' || boolStr == 'yes' || boolStr == i18n.translate('Yes').toLowerCase())
        {
            return true;
        }
        // Translators: Used in boolean values in files
        else if(boolStr === 0 || boolStr == 'false' || boolStr == 'no' || boolStr == i18n.translate('No').toLowerCase())
        {
            return false;
        }
        else
        {
            throw('Unrecognized boolean value: '+boolStr);
        }
    },
    /*
     * A simple "sleep" function that takes a sleep time in seconds and then
     * uses wait.for and a setTimeout to do the sleeping
     */
    sleep: function (sleepTime)
    {
        sleepTime = sleepTime*1000;
        wait.for(function (cb) {
                setTimeout(function() { cb(); }, sleepTime);
        });
    },
    /*
     * Sets booleans for fields. Reads fields from "entry" and stashes it into
     * meta.fields.[]
     */
    storeFieldBools: function (entry, meta)
    {
        for(let field in entry)
        {
            meta.fields[field] = true;
        }
    },

    /*
     * Retrieve a checksum
     */
    checksum: function (targetStr)
    {
		let shasum = crypto.createHash('sha1');
        shasum.update(targetStr);
        return shasum.digest('hex');
    },
};

/*
 * Core bits of software not directly related to games, movies or tv, and not
 * quite helpers for other things
 */
var core = {
    /*
     * Writes a out the final dataset and HTML fiels for a collection group
     */
    writeOutResult: function (groupMeta,groupData,groupNo,name,config,results)
    {
        groupMeta.genres.sort();
        groupMeta.genres = _.uniq(groupMeta.genres,true);

        let dataset = {
            i18n: i18n.strings,
            config: config,
            data: groupData,
            meta: groupMeta,
            // dVer is the dataset version, it is validated in the front-end JS
            // to make sure that it doesn't try to render an unsupported dataset
            // version. Should only be bumped on a non-backwards compatible change.
            // The test in rotcelloc.js also needs to be modified in that case.
            dVer: 0,
            version: packageJSON.version
        };

        let strDataset = JSON.stringify(dataset);
        let checksum = helper.checksum(strDataset);

        let filename = webappGen.writePageFor(name,groupNo,results,checksum);

        fs.writeFileSync(helper.resolveOutPath('out/'+name.toLowerCase().replace(/\s+/g,'_')+'.dataset.json'),strDataset);
    },
    /*
     * Loads the config, the i18n data, then hands control over to the various
     * APIs to let them build the actual databases.
     */
    constructDatabase:function()
    {
        let config  = helper.getConfig(),
            nameMap = {};

        cache = new rotcellocCache();
        if(config.language && fs.existsSync(helper.resolvePath('i18n/'+config.language+'.po')))
        {
            i18n.strings = po2json.parseFileSync(helper.resolvePath('i18n/'+config.language+'.po'), {
                    format: 'mf',
                    'fallback-to-msgid':true
            });
        }
        let groupNo = 0,
            results = [];
        for (let name in config.collections)
        {
            groupNo++;
            printv(2,' Constructing group "'+name+'"');
            let groupConf = config.collections[name];
            let result;
            if(groupConf.type == 'series' || groupConf.type == 'movies')
            {
                let handler = new movieCollection(groupConf,name,groupNo);
                result = handler.generateDatastructure();
            }
            else if(groupConf.type == 'games')
            {
                let handler = new gameCollection(groupConf,name,groupNo);
                result = handler.generateDatastructure();
            }
            else
            {
                throw('Unhandled group type: '+groupConf.type+' for '+groupConf.name);
            }
            results.push({
                    result: result,
                    groupNo: groupNo,
                    name: name,
                    config: config,
            });
        }
        for(let entry of results)
        {
            core.writeOutResult(entry.result.meta, entry.result.data, entry.groupNo, entry.name, entry.config, results);
        }
        cache.autoExpireOutdatedEntries();
        cache.write();
    },
    /*
     * Expires unused entries from the database. Will perform a database
     * construction first
     */
    performCacheExpiry: function ()
    {
        printv(1,'First generating database to get cache usage information ...');
        // Reset verbosity so that we don't get a lot of messages while performing
        // the database construction
        let verbosity = commander.verbose;
        commander.verbose = 0;
        // Construct the database
        core.constructDatabase();
        // Reset the verbosity
        commander.verbose = verbosity;

        let cacheTypes = [ 'URLs', 'meta','gameMeta' ],
            ckey;
        printv(2,'Searching for and purging unused cache keys...');
        for (let type of cacheTypes)
        {
            if(cache[type])
            {
                for(ckey in cache[type])
                {
                    if (!runtimeCache._cacheReads[ckey])
                    {
                        printv(1,'Expired unused key "'+ckey+'" of the type '+type);
                        delete(cache[type][ckey]);
                    }
                }
            }
        }
        printv(2,'Searching for and purging unused files...');
        let reverseFileMap = {};
        for(ckey in cache.URLs)
        {
            reverseFileMap[ cache.get('URLs',ckey) ] = ckey;
        }
        let files = wait.for(glob,helper.resolveOutPath('.images/orig/*'));
        for(let file of files)
        {
            let baseFile = path.basename(file);
            let remove = null;
            if (!cache.get('fileMap',baseFile))
            {
                remove = "not in fileMap";
            }
            else
            {
                let url = cache.get('fileMap',baseFile);
                if (!reverseFileMap[url])
                {
                    remove = "not in reverseFileMap ["+url+"]";
                }
            }
            if(remove)
            {
                fs.unlinkSync(file);
                printv(1,'Removed file: '+file);
                printv(2,'Reason for removal: '+remove);
            }
        }
        let resizedFiles = wait.for(glob,helper.resolveOutPath('.images/*'));
        for(let resizedFile of resizedFiles)
        {
            if(fs.statSync(resizedFile).isFile())
            {
                let baseResizedFile = path.basename(resizedFile);
                if (! fs.existsSync(helper.resolveOutPath('.images/orig/'+baseResizedFile)))
                {
                    fs.unlinkSync(resizedFile);
                    printv(1,'Removed file: '+resizedFile);
                }
            }
        }
        cache.write();
    },
    /*
     * Verifies command-line dependencies
     */
    verifyDeps: function ()
    {
        let errOut = false;
        if (!helper.inPath('sass'))
        {
            console.log('Error: "sass" is missing, it is required to compile the CSS\nPlease install sass (either through the package manager or with "gem install sass")');
            errOut = true;
        }
        if (!helper.inPath('convert'))
        {
            console.log('Error: "convert" is missing, it is required to resize images\nPlease install imagemagick');
            errOut = true;
        }
        if (!helper.inPath('rsync'))
        {
            console.log('Error: "rsync" is missing, it is required to copy files\nPlease install rsync');
            errOut = true;
        }
        if(errOut)
        {
            process.exit(1);
        }
    },
    /*
     * Wrapper that performs the actual building
     */
    build: function ()
    {
        core.verifyDeps();
        // Load the config. Also verifies that it actually exists and outputs
        // an error if it doesn't.
        let config = helper.getConfig();
        printv(1,'rotcelloc version '+packageJSON.version+' running');

        if (commander.deploy && config.deployTo == null)
        {
            console.log('ERROR: deployTo is not set in the config. Can not deploy.');
            process.exit(1);
        }

        if(fs.existsSync(helper.resolveOutPath('out')))
        {
            printv(1,'Cleaning up old files...');
            // Keep the old tarball if it exists
            if(fs.existsSync(helper.resolveOutPath('out/rotcelloc.tar.bz2')))
            {
                if(fs.existsSync(helper.resolveOutPath('rotcelloc.tar.bz2~')))
                {
                    fs.unlinkSync(helper.resolveOutPath('rotcelloc.tar.bz2~'));
                }
                fs.renameSync(helper.resolveOutPath('out/rotcelloc.tar.bz2'),helper.resolveOutPath('.rotcelloc.tar.bz2~'));
            }
            let oldFiles = wait.for(glob,helper.resolveOutPath('out/*'));
            for (let oldFile of oldFiles)
            {
                if(fs.statSync(oldFile).isFile())
                {
                    fs.unlinkSync(oldFile);
                }
            }
        }
        if (!fs.existsSync(helper.resolveOutPath('out')))
        {
            fs.mkdirSync(helper.resolveOutPath('out'));
        }
        if (!fs.existsSync(helper.resolveOutPath('.images')))
        {
            fs.mkdirSync(helper.resolveOutPath('.images'));
        }
        if (!fs.existsSync(helper.resolveOutPath('.images/orig')))
        {
            fs.mkdirSync(helper.resolveOutPath('.images/orig'));
        }
        if(fs.existsSync(helper.resolveOutPath('.rotcelloc.tar.bz2~')))
        {
            fs.renameSync(helper.resolveOutPath('.rotcelloc.tar.bz2~'),helper.resolveOutPath('out/rotcelloc.tar.bz2'));
        }

        printv(1,'Building database...');
        core.constructDatabase();
        printv(1,'Preparing images...');
        let files = wait.for(glob,helper.resolveOutPath('.images/orig/*'));
        for(let file of files)
        {
            if(! fs.existsSync(helper.resolveOutPath('.images/'+path.basename(file))))
            {
                printv(3,'Creating resized version of '+path.basename(file));
                child_process.execFileSync('convert', [ '-resize', '270x', file, helper.resolveOutPath('.images/'+path.basename(file)) ], { stdio: 'inherit' });
            }
        }
        printv(1,'Preparing webapp...');
        webappGen.finalize();
        if(commander.deploy)
        {
            printv(1,'Deploying with rsync...');
            child_process.execFileSync('rsync', [ '--checksum', '-avh', '--progress', '--partial', '--inplace','--exclude=images/orig', '--delete-excluded', '--delete','out/',config.deployTo ], { stdio: 'inherit' });
        }
    },
    /*
     * Write the "complete and corresponding" source code for the installed
     * version of rotcelloc to a file
     */
    writeCCS: function ()
    {
        let selfFiles = [
            { 'path': 'README.md' },
            { 'path': 'Makefile' },
            { 'path': 'LICENSE' },
            { 'path': 'NEWS' },
            { 'path': 'package.json' },
            { 'path': 'rotcelloc.config.cson.tpl' },
            { 'path': 'src/rotcelloc.js' },
            { 'path': 'src/template.ejs' },
            { 'path': 'src/style.css.scss' },
            { 'path': 'src/images/missing.png' },
            { 'path': 'tools/gogExporterBookmarklet.js' },
            { 'path': 'tools/imdbConvert' }
        ];

        for (let globbed of [ 'i18n/*.po*','examples/*.csv','examples/*cson'])
        {
            let baseDir = path.dirname(globbed);
            for(let subfile of wait.for(glob,helper.resolvePath(globbed)))
            {
                selfFiles.push({
                    path: baseDir+'/'+path.basename(subfile),
                    qualified: subfile
                });
            }
        }
        selfFiles.unshift({ 'path': 'rotcelloc', 'qualified':__filename });
        if(fs.existsSync(helper.resolveOutPath('out/rotcelloc.tar.bz2')))
        {
            // There's already a tarball. We do a stupid comparison between the
            // tarball and ourselves, if we're newer than the tarball, we
            // generate a new one anyway, otherwise we keep the existing one.
            let tarball = fs.statSync(helper.resolveOutPath('out/rotcelloc.tar.bz2'));
            let tarballUpToDate = true;
            for(let comparison of selfFiles)
            {
                let compare = fs.statSync(helper.resolvePath(comparison.path));
                if(compare.mtime.getTime() > tarball.mtime.getTime())
                {
                    tarballUpToDate = false;
                    break;
                }
            }
            if(tarballUpToDate)
            {
                printv(4,'Keeping existing source code archive');
                return;
            }
            else
            {
                printv(4,'A source code archive already existed, but rotcelloc is newer than it is. Will regenerate the archive.');
                fs.unlinkSync(helper.resolveOutPath('out/rotcelloc.tar.bz2'));
            }
        }
        printv(3,'Generating source code archive...');

        let currCWD = process.cwd();
        if (!fs.existsSync(helper.resolveOutPath('out/rotcelloc/')))
        {
            fs.mkdirSync(helper.resolveOutPath('out/rotcelloc'));
        }
        process.chdir(helper.resolveOutPath('out'));

        let directories = [];
        for(let file of selfFiles)
        {
            if (!file.qualified)
            {
                file.qualified = helper.resolvePath(file.path);
            }
            let dirTree = path.dirname(file.path);
            if(dirTree == file || dirTree == '.')
            {
                dirTree = '';
            }
            if(dirTree)
            {
                if (!fs.existsSync(helper.resolveOutPath('out/rotcelloc/'+dirTree)))
                {
                    fs.mkdirSync(helper.resolveOutPath('out/rotcelloc/'+dirTree));
                }
                directories.unshift(dirTree);
            }
            child_process.execFileSync('cp',[ file.qualified,helper.resolveOutPath('out/rotcelloc/'+file.path) ]);
        }
        child_process.execFileSync('tar',['-jcf','./rotcelloc.tar.bz2','./rotcelloc' ]);
        directories.sort(function(a, b){
                return b.length - a.length;
        });
        for(let fileI of selfFiles)
        {
            fs.unlinkSync('./rotcelloc/'+fileI.path);
        }
        for(let dirI of directories)
        {
            if(fs.existsSync('./rotcelloc/'+dirI))
            {
                fs.rmdirSync('./rotcelloc/'+dirI);
            }
        }
        printv(3,'Wrote source code archive to rotcelloc.tar.bz2');
        fs.rmdirSync('./rotcelloc');
        process.chdir(currCWD);
    }
};

/*
 * Web application generator components
 */
var webappGen = {
    versions: {
        jQueryVersion: '2.2.1',
        bootstrapVersion: '3.3.6'
    },
    createFilename: function(name,groupNo)
    {
        let filename;
        if(groupNo == 1)
        {
            filename = 'index.html';
        }
        else
        {
            filename = name.toLowerCase().replace(/\s+/g,'_');
            filename += '.html';
        }
        return filename;
    },
    writePageFor: function (name,groupNo,results,checksum)
    {
        let filename = webappGen.createFilename(name,groupNo);
        let template = fs.readFileSync(helper.resolvePath('src/template.ejs'));
        template = template.toString();
        let footer = util.format(i18n.translate('Generated by <a href="%s">%s</a> version %s. <a href="%s">Download source code.</a> Software licensed under the <a target="_blank" href="%s">%s</a>. Content is copyrighted by their respective owners.'),'http://random.zerodogg.org/','rotcelloc',packageJSON.version,'rotcelloc.tar.bz2','https://gnu.org/licenses/agpl-3.0-standalone.html','GNU AGPLv3');
        let menu = [];
        for(let entry of results)
        {
            let fname = webappGen.createFilename(entry.name,entry.groupNo);
            menu.push({
                    url: fname,
                    state: entry.groupNo == groupNo ? 'current' : '',
                    title: entry.name
            });
        }
        let content = ejs.render(template, {
                document: {
                    title: name,
                },
                versions: webappGen.versions,
                config: helper.getConfig(),
                footer: footer,
                menu: menu,
                content: '<div class="searchForm" id="searchForm"></div><div id="collResultTarget" data-checksum="'+checksum+'" data-pagetype="'+name+'">'+i18n.translate('Loading collection...')+'</div>',
            },
            {
                rmWhitespace: true
            }
        );
        fs.writeFileSync(helper.resolveOutPath('out/'+filename),content);
    },
    finalize: function ()
    {

        if (!fs.existsSync(helper.resolvePath('src/deps/bootstrap-variables.scss')))
        {
            printv(1,'Fetching dependency: bootstrap-variables.scss');
            let bootstrapVars = wait.forMethod(httpreq,'get', 'https://raw.githubusercontent.com/twbs/bootstrap-sass/v'+webappGen.versions.bootstrapVersion+'/assets/stylesheets/bootstrap/_variables.scss');
            fs.writeFileSync(helper.resolvePath('src/deps/bootstrap-variables.scss'), bootstrapVars.body);
            printv(1,'Continuing...');
        }

        printv(3,'Copying images...');
        // Copies the downloaded posters
        child_process.execFileSync('rsync', [ '-a','--delete', '--exclude=orig/', helper.resolveOutPath('.images/'), helper.resolveOutPath('./out/images/') ]);
        // Copies the "missing" image
        child_process.execFileSync('rsync', [ '-a',helper.resolvePath('src/images/'), helper.resolveOutPath('./out/images/') ]);
        // Copy .gitignore if neded
        if (!fs.existsSync(helper.resolveOutPath('.gitignore')))
        {
            printv(4,'Copied .gitignore to '+helper.resolveOutPath('.gitignore'));
            child_process.execFileSync('rsync', [ '-a',helper.resolvePath('.gitignore'), helper.resolveOutPath('.gitignore') ]);
        }
        printv(3,'Compiling JS and CSS...');
        let uglified = UglifyJS.minify(helper.resolvePath('src/rotcelloc.js'),{
                outSourceMap: 'rotcelloc.js.map',
                sourceMapIncludeSources: true
            });
        fs.writeFileSync(helper.resolveOutPath('out/rotcelloc.js'),uglified.code);
        fs.writeFileSync(helper.resolveOutPath('out/rotcelloc.js.map'),uglified.map);
        child_process.execFileSync('sass',[ '--scss','--quiet',helper.resolvePath('src/style.css.scss'),helper.resolveOutPath('out/style.css') ]);

        try
        {
            core.writeCCS();
        }
        catch(e)
        {
            printv(1,'Warning: failed to write source code archive');
            printv(4,'Error when writing CCS: '+e.message);
        }
    }
};

/*
 * Generates and returns a cache ID string that will be unique to this entry
 * and can be used to store and retrieve data in the persistent cache
 */
function getCacheID (entry,type,opts)
{
    let ckey = '';
    if(type === undefined)
    {
        type = entry.type;
    }
    if(entry.origTitle)
    {
        ckey = entry.origTitle;
    }
    else if(entry.title)
    {
        ckey = entry.title;
    }
    else
    {
        ckey = entry.name;
    }
    if(entry.altTitle)
    {
        ckey += '//'+entry.altTitle;
    }
    ckey += '//'+entry.year;
    if(type == 'series')
    {
        ckey += 'tvserie';
    }
    else if(type == 'game')
    {
        ckey += '//game';
        if(entry.platform)
        {
            ckey += '//'+entry.platform;
        }
        if(entry.steamID && (!opts || !opts.ignoreSteam))
        {
            ckey += '//steam-'+entry.steamID;
        }
    }
    if(runtimeCache._cacheReads)
    {
        runtimeCache._cacheReads[ckey] = true;
    }
    return ckey;
}
/*
 * Prints a message if the verbosity level is high enough
 */
function printv(reqVerb,message)
{
    if(commander.verbose >= reqVerb)
    {
        if (reqVerb > 1 && !/^\s+/.test(message))
        {
            let spaces = '';
            for(let n = 1; reqVerb >= n; n++)
            {
                spaces += ' ';
            }
            message = spaces+message;
        }
        console.log(message);
    }
}
/*
 * Main entry points. Parses and performs actions depending on the command-line
 * parameters
 */
function main()
{
    try
    {
        packageJSON = JSON.parse(fs.readFileSync(helper.resolvePath('package.json')));
    }
    catch(e)
    {
        packageJSON = { 'version':'UNKNOWN' };
    }

    commander
    .version(packageJSON.version)
    .option('-q, --quiet','be quiet (overrides any --verbose arguments)')
    .option('-v, --verbose','increase verbosity', function (v,total) { return total + 1;},1)
    .option('--deploy','build the collection and webapp and then deploy as defined in the config')
    .option('--retry-miss','retry fetching data or covers where those have failed previously')
    .option('--include-debug','include debugging metadata')
    .option('--expire-meta','expire all cached metadata from the cache')
    .option('--expire-covers','expire all cached covers from the cache')
    .option('--expire-matching [match]','expire all cached data where the key case insensitively matches [match] and exit')
    .option('--expire-matching-miss [match]','same as above, but only expire cached failures')
    .option('--expire-unused','expire all unused cache entries')
    .option('--force-steam-update','force an update of the lists of Steam games')
    .option('--config [file]','read [file] instead of ./rotcelloc.config.json')
    .option('--lazy','only use cached data')
    .parse(process.argv);

    if(commander.quiet)
    {
        commander.verbose = 0;
    }
    else if (!commander.verbose)
    {
        commander.verbose = 1;
    }
    if(commander.expireUnused)
    {
        runtimeCache._cacheReads = {};
    }

    if (!fs.existsSync(helper.resolvePath('src/rotcelloc.js')))
    {
        console.log('Run me from the right directory (root of the tree)');
        process.exit(1);
    }

    /* Handle exclusive options */
    if(commander.expireMatching)
    {
        cache = new rotcellocCache();
        cache.cacheExpiry(commander.expireMatching);
        process.exit(0);
    }
    else if(commander.expireMatchingMiss !== undefined)
    {
        cache = new rotcellocCache();
        cache.cacheExpiry(commander.expireMatchingMiss,true);
        process.exit(0);
    }

    if(commander.expireUnused)
    {
        core.performCacheExpiry();
        process.exit(0);
    }

    core.build();
}

/*
 * Executes "main" inside a fiber instance, which is then used by waitfor to
 * make functions that are normally async execute synchronously.
 */
wait.launchFiber(main);
